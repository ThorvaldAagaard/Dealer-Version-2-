<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see https://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2013-07-03T14:47:11" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2023-02-17T22:29:46.892856514" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
    @page {  }
    table { border-collapse:collapse; border-spacing:0; empty-cells:show }
    td, th { vertical-align:top; font-size:12pt;}
    h1, h2, h3, h4, h5, h6 { clear:both;}
    ol, ul { margin:0; padding:0;}
    li { list-style: none; margin:0; padding:0;}
    /* "li span.odfLiEnd" - IE 7 issue*/
    li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
    span.footnodeNumber { padding-right:1em; }
    span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
    span.heading_numbering { margin-right: 0.8rem; }* { margin:0;}
    .gr1 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.2008in;min-width:0.5811in;vertical-align:top; }
    .gr2 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; padding-top:0.0098in; padding-bottom:0.0098in; padding-left:0.0098in; padding-right:0.0098in; vertical-align:top; }
    .gr3 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; padding-top:0.0102in; padding-bottom:0.0102in; padding-left:0.0102in; padding-right:0.0102in; vertical-align:top; }
    .gr4 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.2835in;min-width:0.2835in;vertical-align:top; }
    .gr5 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.2846in;min-width:0.2846in;vertical-align:top; }
    .gr6 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.2665in;vertical-align:top; }
    .gr7 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.5118in;vertical-align:top; }
    .gr8 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.2835in;min-width:0.2835in;vertical-align:top; }
    .gr9 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; min-height:0.2571in;vertical-align:top; }
    .Contents_20_1 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .Contents_20_2 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.1965in; margin-right:0in; text-indent:0in; }
    .Contents_20_3 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.3929in; margin-right:0in; text-indent:0in; }
    .Contents_20_Heading { font-size:16pt; font-weight:bold; margin-bottom:0.0835in; margin-left:0in; margin-right:0in; margin-top:0.1665in; text-indent:0in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .Header { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .Heading_20_1 { font-size:17pt; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;margin-left:0.2in; margin-right:0in; margin-top:0.0902in; margin-bottom:0.0201in; text-indent:-0.3in; font-weight:bold; }
    .Heading_20_2 { font-size:115%; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;font-weight:bold; }
    .Heading_20_3 { font-size:14pt; margin-bottom:0.0835in; margin-top:0.0972in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;color:#808080; font-weight:bold; }
    .P1 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P10 { font-size:10pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P100 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P101 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P102 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P103 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P104 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P105 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P106 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P107 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P108 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P109 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P11 { font-size:10pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;text-decoration:none ! important; }
    .P110 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P111 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P112 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P113 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P114 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P115 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P116 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P117 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P118 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-style:italic; }
    .P119 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-style:normal; }
    .P12 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P120 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P121 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P122 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P123 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P124 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P125 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P126 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P127 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P128 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P129 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P13 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P130 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P131 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P132 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P133 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P134 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P135 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P136 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P137 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P138 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P139 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P14 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P140 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P141 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P142 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P143 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P144 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-align:left ! important; color:#000000; }
    .P145 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P146 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P147 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P148 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P149 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P15 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;text-decoration:none ! important; }
    .P150 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P151 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P152 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P153 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P154 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P155 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P156 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P157 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P158 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P159 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P16 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P160 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:transparent; }
    .P161 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:transparent; }
    .P162 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:transparent; }
    .P163 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-decoration:none ! important; }
    .P164 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P165 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P166 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P167 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P168 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P169 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P17 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;background-color:transparent; }
    .P170 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P171_borderStart { font-size:12pt; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:#dee6ef; padding-bottom:0.0835in;  border-bottom-style:none; }
    .P171 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:#dee6ef; padding-bottom:0.0835in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
    .P171_borderEnd { font-size:12pt; margin-bottom:0.0835in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:#dee6ef; padding-top:0in;  border-top-style:none;}
    .P172 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P173 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P174_borderStart { font-size:12pt; margin-left:0.3937in; margin-right:0.3937in; margin-top:0in; text-indent:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-style:italic; background-color:#dee6ef; padding-bottom:0.1965in;  border-bottom-style:none; }
    .P174 { font-size:12pt; margin-left:0.3937in; margin-right:0.3937in; text-indent:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-style:italic; background-color:#dee6ef; padding-bottom:0.1965in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
    .P174_borderEnd { font-size:12pt; margin-bottom:0.1965in; margin-left:0.3937in; margin-right:0.3937in; text-indent:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-style:italic; background-color:#dee6ef; padding-top:0in;  border-top-style:none;}
    .P175 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P176 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P177 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P178 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P179 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P18 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P180 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P181 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P182 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P183 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0.4925in; margin-right:0in; text-indent:0in; }
    .P184 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P185 { font-size:12pt; margin-bottom:0.0835in; margin-top:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P186 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P187 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P188 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P189 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P19 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P190 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P191 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P192 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P193 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P194 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P195 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P196 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-left:0in; margin-right:0in; text-indent:0in; }
    .P197 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P2 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P20 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P201 { font-size:12pt; margin-left:0in; margin-right:0in; text-indent:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P202 { font-size:12pt; margin-left:0.1965in; margin-right:0in; text-indent:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P203 { font-size:12pt; margin-left:0.3929in; margin-right:0in; text-indent:0in; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P204 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P205 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P206 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P207 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P208 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P209 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P21 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P210 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P211 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P212 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P213 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P214 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P215 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P216 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P217 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P218 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P219 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P22 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P220 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;text-align:center ! important; }
    .P221 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;text-align:center ! important; }
    .P222 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;text-align:left ! important; }
    .P223 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P224 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P225 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;}
    .P226 { font-size:17pt; font-weight:bold; margin-bottom:0.0201in; margin-left:0.2in; margin-right:0in; margin-top:0.0902in; text-indent:-0.3in; font-family:Arial; writing-mode:horizontal-tb; direction:ltr;text-align:center ! important; }
    .P227 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P228 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P229 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P23 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P230 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P231 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P232 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P233 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P234 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P235 { font-size:115%; font-weight:bold; margin-bottom:0.0201in; margin-top:0.0799in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P236 { color:#808080; font-size:14pt; font-weight:bold; margin-bottom:0.0835in; margin-top:0.0972in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P237 { color:#808080; font-size:14pt; font-weight:bold; margin-bottom:0.0835in; margin-top:0.0972in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P238 { color:#808080; font-size:14pt; font-weight:bold; margin-bottom:0.0835in; margin-top:0.0972in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P239 { color:#808080; font-size:14pt; font-weight:bold; margin-bottom:0.0835in; margin-top:0.0972in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P24 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P240 { color:#808080; font-size:14pt; font-weight:bold; margin-bottom:0.0835in; margin-top:0.0972in; font-family:Liberation Sans; writing-mode:horizontal-tb; direction:ltr;}
    .P241 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P242 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P243 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-style:italic; }
    .P244 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P245 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P246 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P247 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P248 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P249 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P25 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P250 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P251 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P252 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P253 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P254 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; text-align:center ! important; }
    .P255 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-align:center ! important; }
    .P256 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; text-align:center ! important; }
    .P257 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; }
    .P258 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr; }
    .P26 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P27 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P28 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-decoration:underline; }
    .P29 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P3 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P30 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P31 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:bold; background-color:#dee6ef; }
    .P32 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:bold; background-color:#dde8cb; }
    .P33 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; }
    .P34 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; }
    .P35 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P36 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:#dee6ef; }
    .P37 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P38 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P39 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; }
    .P4 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P40 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; background-color:#dee6ef; }
    .P41 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; background-color:#dee6ef; }
    .P42 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; background-color:#dee6ef; }
    .P43 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; background-color:#dee6ef; }
    .P44 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; background-color:transparent; }
    .P45 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:normal; background-color:transparent; }
    .P46 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P47 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P48 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P49 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P5 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P50 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:bold; }
    .P51 { font-size:10pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:bold; }
    .P52 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-decoration:underline; }
    .P53 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-decoration:underline; }
    .P54 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P55 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:#dde8cb; }
    .P56 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P57 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P58 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P59 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P6 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;background-color:#dee7e5; }
    .P60 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P61 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;font-weight:bold; }
    .P62 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P63 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P64 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P65 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P66 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P67 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P68 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P69 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P7 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;background-color:#dee7e5; }
    .P70 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P71 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P72 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P73 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P74 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P75 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P76 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P77 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P78 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P79 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;text-decoration:none ! important; }
    .P8 { font-size:12pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P80 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P81 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P82 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P83 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P84 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P85 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P86 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P87 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P88 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P89 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P9 { font-size:10pt; font-family:Courier New; writing-mode:horizontal-tb; direction:ltr;}
    .P90 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P91 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;background-color:transparent; }
    .P92 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P93 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P94 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P95 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P96 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P97 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P98 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .P99 { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .Standard { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;}
    .Text_20_body { font-size:12pt; font-family:Liberation Serif; writing-mode:horizontal-tb; direction:ltr;margin-top:0in; margin-bottom:0.0835in; }
    .Bullet_20_Symbols { font-family:OpenSymbol; }
    .Internet_20_link { color:#000080; text-decoration:underline; }
    .T10 { font-weight:bold; }
    .T100 { font-family:Liberation Serif; font-style:italic; font-weight:bold; }
    .T101 { font-family:Liberation Serif; }
    .T102 { font-family:Liberation Serif; }
    .T103 { font-family:Liberation Serif; }
    .T104 { font-family:Liberation Serif; }
    .T105 { font-family:Liberation Serif; }
    .T106 { font-family:Liberation Serif; font-weight:bold; }
    .T107 { font-family:Liberation Serif; background-color:#dee7e5; }
    .T108 { font-family:Liberation Serif; }
    .T109 { font-family:Liberation Serif; }
    .T11 { font-weight:bold; }
    .T110 { font-family:Liberation Serif; }
    .T111 { font-family:Liberation Serif; }
    .T112 { font-family:Liberation Serif; }
    .T113 { font-family:Liberation Serif; }
    .T114 { font-family:Liberation Serif; }
    .T115 { font-family:Liberation Serif; }
    .T12 { font-weight:bold; }
    .T124 { background-color:transparent; }
    .T125 { background-color:transparent; }
    .T126 { background-color:transparent; }
    .T127 { background-color:transparent; }
    .T128 { background-color:transparent; }
    .T129 { background-color:transparent; }
    .T13 { font-weight:bold; }
    .T130 { background-color:transparent; }
    .T131 { background-color:transparent; }
    .T132 { background-color:transparent; }
    .T133 { background-color:transparent; }
    .T14 { font-weight:bold; }
    .T148 { vertical-align:super; font-size:58%;font-size:14pt; }
    .T149 { vertical-align:super; font-size:58%;font-size:14pt; }
    .T15 { font-weight:bold; }
    .T150 { vertical-align:super; font-size:58%;background-color:transparent; }
    .T151 { font-size:12pt; }
    .T152 { font-size:14pt; }
    .T157 { text-decoration:underline; }
    .T158 { text-decoration:underline; }
    .T159 { text-decoration:underline; }
    .T16 { font-weight:bold; }
    .T160 { text-decoration:underline; }
    .T161 { text-decoration:underline; }
    .T162 { text-decoration:underline; }
    .T163 { text-decoration:underline; }
    .T164 { text-decoration:underline; }
    .T166 { text-decoration:none ! important; }
    .T167 { text-decoration:none ! important; }
    .T168 { text-decoration:none ! important; }
    .T169 { text-decoration:none ! important; }
    .T17 { font-weight:bold; }
    .T170 { text-decoration:none ! important; }
    .T171 { text-decoration:none ! important; }
    .T172 { text-decoration:none ! important; }
    .T173 { text-decoration:none ! important; }
    .T174 { text-decoration:none ! important; }
    .T175 { text-decoration:none ! important; }
    .T176 { text-decoration:none ! important; background-color:#dee6ef; }
    .T177 { text-decoration:none ! important; }
    .T178 { text-decoration:none ! important; }
    .T18 { font-weight:bold; }
    .T181 { font-size:10pt; }
    .T182 { font-size:10pt; }
    .T183 { font-size:10pt; }
    .T184 { font-size:10pt; }
    .T19 { font-weight:bold; background-color:#dee6ef; }
    .T190 { background-color:#dee7e5; }
    .T191 { background-color:#dee7e5; }
    .T192 { background-color:#dee7e5; }
    .T193 { background-color:#dee7e5; }
    .T194 { background-color:#dee7e5; }
    .T20 { font-weight:bold; background-color:#dee6ef; }
    .T21 { font-weight:bold; background-color:#dee6ef; }
    .T212 { color:#c9211e; font-weight:bold; }
    .T213 { color:#c9211e; font-weight:bold; }
    .T214 { color:#c9211e; font-size:10pt; font-weight:bold; }
    .T215 { color:#c9211e; font-size:10pt; font-weight:bold; }
    .T217 { color:#000000; font-weight:normal; }
    .T269 { font-size:12pt; }
    .T270 { font-size:10pt; }
    .T33 { font-weight:normal; }
    .T34 { font-weight:normal; }
    .T35 { font-weight:normal; }
    .T36 { font-weight:normal; }
    .T37 { font-weight:normal; }
    .T38 { font-weight:normal; }
    .T39 { font-weight:normal; }
    .T40 { font-weight:normal; }
    .T43 { background-color:#dee6ef; }
    .T44 { background-color:#dee6ef; }
    .T45 { background-color:#dee6ef; }
    .T46 { background-color:#dee6ef; }
    .T47 { background-color:#dee6ef; }
    .T48 { background-color:#dee6ef; }
    .T49 { background-color:#dee6ef; }
    .T5 { font-family:Arial; font-size:17pt; font-weight:bold; }
    .T50 { background-color:#dee6ef; }
    .T51 { background-color:#dee6ef; }
    .T52 { background-color:#dee6ef; }
    .T53 { background-color:#dee6ef; }
    .T56 { font-family:Courier New; }
    .T57 { font-family:Courier New; }
    .T58 { font-family:Courier New; }
    .T59 { font-family:Courier New; }
    .T6 { font-family:Arial; font-size:17pt; font-weight:bold; }
    .T60 { font-family:Courier New; background-color:#dee7e5; }
    .T61 { font-family:Courier New; font-size:11pt; }
    .T62 { font-family:Courier New; }
    .T63 { font-family:Courier New; }
    .T64 { font-family:Courier New; }
    .T65 { font-family:Courier New; }
    .T66 { font-family:Courier New; text-decoration:none ! important; }
    .T67 { font-family:Courier New; text-decoration:none ! important; }
    .T68 { font-family:Courier New; text-decoration:none ! important; }
    .T69 { font-family:Courier New; text-decoration:none ! important; background-color:#dee6ef; }
    .T7 { font-family:Arial; font-size:17pt; font-weight:bold; background-color:transparent; }
    .T70 { font-family:Courier New; text-decoration:none ! important; background-color:#dee6ef; }
    .T71 { font-family:Courier New; }
    .T72 { font-family:Courier New; }
    .T73 { font-family:Courier New; background-color:#dee6ef; }
    .T74 { font-family:Courier New; background-color:#dee6ef; }
    .T75 { font-family:Courier New; }
    .T76 { font-family:Courier New; }
    .T77 { font-family:Courier New; font-size:10pt; background-color:transparent; }
    .T78 { font-family:Courier New; }
    .T79 { font-family:Courier New; }
    .T8 { font-style:italic; }
    .T80 { font-family:Courier New; }
    .T81 { font-family:Courier New; }
    .T82 { font-family:Courier New; }
    .T83 { font-family:Courier New; }
    .T84 { font-family:Courier New; }
    .T85 { font-family:Courier New; }
    .T86 { font-family:Courier New; }
    .T87 { font-family:Courier New; }
    .T9 { font-style:italic; background-color:transparent; }
    .T90 { font-family:Liberation Serif; }
    .T91 { font-family:Liberation Serif; font-size:12pt; font-weight:normal; }
    .T92 { font-family:Liberation Serif; font-size:12pt; font-weight:normal; }
    .T93 { font-family:Liberation Serif; }
    .T94 { font-family:Liberation Serif; }
    .T95 { font-family:Liberation Serif; }
    .T96 { font-family:Liberation Serif; }
    .T97 { font-family:Liberation Serif; font-style:italic; }
    .T98 { font-family:Liberation Serif; font-style:italic; }
    .T99 { font-family:Liberation Serif; font-style:italic; font-weight:bold; }
    /* ODF styles with no properties representable as CSS */
    .Sect1 .Index_20_Link .T1 .T116 .T117 .T118 .T119 .T120 .T121 .T122 .T123 .T134 .T135 .T136 .T137 .T138 .T139 .T140 .T141 .T142 .T143 .T144 .T145 .T146 .T147 .T153 .T154 .T155 .T156 .T165 .T179 .T180 .T185 .T186 .T187 .T188 .T189 .T195 .T196 .T197 .T198 .T199 .T200 .T201 .T202 .T203 .T204 .T205 .T206 .T207 .T208 .T209 .T210 .T211 .T216 .T218 .T219 .T22 .T220 .T221 .T222 .T223 .T224 .T225 .T226 .T227 .T228 .T229 .T23 .T230 .T231 .T232 .T233 .T234 .T235 .T236 .T237 .T238 .T239 .T24 .T240 .T241 .T242 .T243 .T244 .T245 .T246 .T247 .T248 .T249 .T25 .T250 .T251 .T252 .T253 .T254 .T255 .T256 .T257 .T258 .T259 .T26 .T260 .T261 .T262 .T263 .T264 .T265 .T266 .T267 .T268 .T27 .T28 .T29 .T3 .T30 .T31 .T32 .T4 .T41 .T42 .T54 .T55 .T88 .T89  { }
    </style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><h1 class="P222"><a id="a__Dealer_Maintenance_Notes_by_JGM"><span/></a><a id="__RefHeading___Toc3480_643984236"/><span class="T5">Dealer Maintenance Notes</span><span class="T3"> </span><span class="T187">               </span><span class="T3">                           by </span><span class="T6">JGM</span></h1><table border="0" cellspacing="0" cellpadding="0" class="Sect1"><colgroup/><p class="Contents_20_Heading">Table of Contents</p><tr><td><p class="P201"><a href="#__RefHeading___Toc3480_643984236">Dealer Maintenance Notes by JGM</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3484_643984236">Preamble</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc29070_2914024446">Conventions Used in this Document</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3486_643984236">Overview</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3488_643984236">Workflow</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3490_643984236">Maintenance 2022</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3492_643984236">Hierarchy of Files</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3463_3437249550">Dealer Heritage</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc3496_643984236">Portability</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3498_643984236">Novice's Introduction to Bison/Yacc and Flex</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3500_643984236">Overview</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3502_643984236">The Lexing Process -- Flex</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc3504_643984236">The Lexing Rules File (.l)</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3506_643984236">Generating The Parser with Bison</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc3508_643984236">The Parsing Rules File (.y)</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3510_643984236">Overview of the Operation of Dealer</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3512_643984236">Evaluating the Condition Clause</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3514_643984236">Code Locations -- src Directory</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc29072_2914024446">Code Locations -- include Directory</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc29074_2914024446">Code Locations -- Other Directories</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3516_643984236">Modification Examples</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3518_643984236">Adding a Title.</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3520_643984236">Adding Losing Trick Count (ltc)</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3522_643984236">Random Number Generation</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3524_643984236">Other Performance Figures</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc3526_643984236">Simple Condition File</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3528_643984236">Double Dummy Analysis with GIB and DDS</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3530_643984236">Experimental Results.</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc29076_2914024446">The condition statement used in the 5x tests</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc3465_3437249550">Performance of the DealerServer</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3309_3276467367">Performance Summary of Various External Programs</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc10468_3480997658">The Shape Functions -- H. van Staveren &amp; F. Dellacherie</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc10470_3480997658">HvS shape( .. )</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc10472_3480997658">shape() Initialization Phase</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc10474_3480997658">shape() Parsing Phase</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc10476_3480997658">Evaluating shape()</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc10478_3480997658">François Dellacherie Shape{ .. }</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc29078_2914024446">Installing Dealer V2 From the Github Repo.</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc29080_2914024446">Warning:</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc29082_2914024446">Installation From the Github Repository</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc29084_2914024446">After Getting The Repository</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc3120_2383521750">FDP</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc29086_2914024446">GIB</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc29088_2914024446">DOP</a></p></td></tr><tr><td><p class="P203"><a href="#__RefHeading___Toc29090_2914024446">The Repository Contents</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc29314_670075485">Appendix - Adding the CSV Report</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3467_3437249550">The DealerServer Infrastructure</a></p></td></tr><tr><td><p class="P201"><a href="#__RefHeading___Toc3469_3437249550">Coding DealerServer Metrics Functions</a></p></td></tr><tr><td><p class="P202"><a href="#__RefHeading___Toc4839_2097399308">Mixing The Results from Two Different Metrics.</a></p></td></tr></table><h1 class="P223"><a id="a__Preamble"><span/></a><a id="__RefHeading___Toc3484_643984236"/>Preamble</h1><p class="P112">While the user documentation for dealer is sufficient there is a lack of documentation for those who want to maintain or modify the program.</p><p class="P115"><span class="T4">The original author is </span>Hans van Staveren<span class="T23">,</span>   Amsterdam<span class="T23">, </span>  Holland <span class="T4">, (circa 1990), the latest maintainer is </span>Henk Uijterwaal <span class="T4">circa 1999. There have not been many changes made to dealer in the last 20 years.</span></p><p class="P112">Dealer is now used by BBO to deal practice hands for its users.</p><p class="P143">Dealer was originally intended to just generate deals of interest for study, bidding practice, perhaps to analyze a line of play and so on. It was not, (and is still not) intended to generate hands for play in tournaments and such like. However it was (and is) such a useful program that many people have added functionality to it over the years. I, JGM, wanted to use it to experiment with different methods of hand evaluation. In order to do that I had to learn a fair bit about Dealer's structure and workings. What you read here is my humble attempt to document my findings in case someone else wants to modify Dealer even further. </p><p class="P143">I should at this time also state that none of the original authors have been involved in my attempt<span class="T138">. If there are any errors in my description herein, they are all my own.</span></p><h2 class="P227"><a id="a__Conventions_Used_in_this_Document"><span/></a><a id="__RefHeading___Toc29070_2914024446"/>Conventions Used in this Document</h2><p class="P165">When you see text in <span class="T56">Courrier New</span> font, that means the text is either input to, or output from the computer. Possibly it is a filename, or directory name. </p><p class="P165">When you see a line of <span class="T56">Courrier New</span> text that ends with a backslash (\) that means that the line as printed on the screen was too long to fit on the page and is continued on the next line. It does not mean that the backslash needs to be typed in, or will appear in the output. </p><p class="P165">Sometimes the text, or program name is highlighted with <span class="T43">like so.</span></p><h1 class="P205"><a id="a__Overview"><span/></a><a id="__RefHeading___Toc3486_643984236"/>Overview</h1><p class="P144">Dealer defines a 'grammar' of user commands in typical BNF form. The user prepares an 'input file' consisting of the instructions written in that grammar as to what kind of bridge deals he wants.</p><p class="P144">Dealer uses the <span class="T43">yacc/bison</span> tools to generate a parser that can process instructions written in that grammar. <span class="T43">yacc/bison</span> relies on a 'lexer', in the case of Linux, <span class="T43">flex</span>, to parse the user's input into tokens.</p><p class="P144">So the structure of dealer is made up of:</p><p class="P144">1) A grammar definition file, called defs.y in the original distribution. JGM has renamed this <span class="T43">dealyacc.y</span> in his code.</p><p class="P144">2) A lexer definition file, called scan.l in the original distribution. JGM has renamed this <span class="T43">dealflex.l</span> in his code.</p><p class="P144">3) A main program and several subroutines, in a file called, <span class="T73">dealer</span><span class="T74">v2</span><span class="T73">.c</span></p><p class="P144">4) Various header files and supporting routine header and code files</p><p class="P144">5) Makefiles</p><p class="P144">6) Examples and regression tests.</p><h1 class="P206"><a id="a__Workflow"><span/></a><a id="__RefHeading___Toc3488_643984236"/>Workflow</h1><p class="P112">YACC stands for, "Yet Another Compiler Compiler". The goal of yacc is to <span class="T54">parse an input file according to the grammar for the target</span> language.</p><p class="P133"><span class="T4">The Dealer workflow is slightly different</span><span class="T54">, from that of a compiler.</span><span class="T4"> The output of YACC/BISON is a routine called yyparse() and its supporting functions as defined in the dealyacc.y file. This routine is compiled into the dealer application along with the other C code.  </span><span class="T54">The user enters his 'input' file  into dealer and the parser produces several in memory data structures that encode the user's instructions.</span></p><h1 class="P207"><a id="a__Maintenance_2022"><span/></a><a id="__RefHeading___Toc3490_643984236"/>Maintenance 202<span class="T142">2</span></h1><p class="P113">The early versions of dealer were developed on a 32 bit SUN workstation which by 2021 standards would not have qualified as a cell phone. Windows95 was not available. So there was considerable effort made to ensure that the code was portable to various flavors of Unix and even to a Unix like environment (Cygwin et. al.) on Windows 3.x.<span class="T201"> and even on DOS.</span></p><p class="P113">As of 202<span class="T142">2</span>, Linux has essentially taken over almost all of the Unix market (there is still some BSD, SUN and AIX but these are unlikely to be relevant to a bridge playing program). <span class="T201">There is also MacOS which has a Unix pedigree, but is now completely closed and proprietary. </span>The systems are almost all 64 bit and at leas<span class="T22">t</span> 1000 times faster than the original SUN workstation. Furthermore, Windows now includes WSL 2.0 which can run almost all Linux command line applications, and even many graphical (X window) applications<span class="T22">,</span> natively.</p><p class="P113">So it does not make a lot of sense to hobble the development of <span class="T234">D</span>ealer with 1990 era constraints. Accordingly JGM has decided to use any feature of Linux/Bison/Flex that seems useful, regardless of portability concerns such as P<span class="T54">OSIX</span> compliance, or Windows tool chains.</p><p class="P114">Furthermore the (Standard ANSI) C language is much improved from 1990, allowing functions to return structures and unions, including some extra libraries for random number generation, firming up function prototype definitions and the like. These features too, are used whenever appropriate.</p><h1 class="P208"><a id="a__Hierarchy_of_Files"><span/></a><a id="__RefHeading___Toc3492_643984236"/>Hierarchy of Files</h1><p class="Standard">dealdefs.h -&gt; dealtypes.h-&gt;dealexterns.h-----<span class="T42">-----v</span>        </p><p class="Standard"><span> </span><span> </span><span>      -&gt; dealglobals.c  ---&gt; dealyacc.y, dealflex.l, dealer<span class="T201">v2</span>.c, deal{xxx}subs.c etc.</span></p><p class="Standard"><span> </span><span> </span><span>      -&gt; dealprotos.h-------<span class="T42">---^</span></span></p><p class="P95"><span> </span><span> </span><span>      -&gt; mmap_template.h--<span class="T255">--</span>--&gt;usereval_subs.c (part of Dealer)</span></p><p class="P97"><span> </span><span> </span><span> <span class="T256">    V</span></span><span> </span><span> </span><span>     |</span></p><p class="P96"><span class="T255">Sub_dir:UserEval</span><span class="T256"> (Where the server code lives)</span></p><p class="P98"> <span class="T256">                </span>|</p><p class="P98"> <span class="T256">               </span>v<span class="T256">----&gt;</span><span class="T257">UserEval_types.h</span><span class="T256">-&gt;</span><span class="T257">UserEval_externs.h</span><span class="T256">----.</span></p><p class="P98"><span class="T256">                                           -&gt;</span><span class="T257">UserEval_globals.c</span><span class="T256">----|</span><span class="T257"> </span></p><p class="P99"><span> </span><span> </span><span>                     -&gt;<span class="T257">UserEval_protos.h</span>----v<span class="T257"> </span></span></p><p class="P96"><span class="T256">                                                        </span><span class="T255">factors_subs.c,metrics_calcs.c ,metrics_util_subs.c</span></p><p class="P101"><span> </span><span> </span><span> </span><span>          <span class="T258">                                        |</span></span></p><p class="P102"><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> v</span></p><p class="P101"><span class="T258">                                                                </span>UserServer.c</p><p class="P100"><span>              <span class="T258">                                </span> Server<span class="T258">_protos.h---------^         </span></span></p><p class="P96"> </p><p class="P96">   </p><h2 class="Heading_20_2"><a id="a__Dealer_Heritage"><span/></a><a id="__RefHeading___Toc3463_3437249550"/><span class="T257">  </span>Dealer Heritage</h2><p class="P117">This <span class="T24">next bit is </span>taken from the original dealer documentation; it gives a flavor of what the landscape was like back in 1989-ish when the program was first developed<span class="T24">, and in the years immediately following</span>.<span class="T24"> </span></p><p class="P132">&lt;Quote&gt;</p><h3 class="Heading_20_3"><a id="a__Portability"><span/></a><a id="__RefHeading___Toc3496_643984236"/>Portability</h3><p class="P118">The program has been developed under SunOS on Sun hardware. I (Hans) am a reasonably competent programmer though, and I expect the program to be highly portable. The most suspect part is in the initialization of the random number generator. The system call used here might need to be changed on other OSes. </p><p class="P118">There has been a DOS and OS/2 port by Pedl Rau. I tested the speed at about 9000 hands a second on my 486DX33. <span class="T10">Note:</span> this has been superseded by the work from (a.o.) Paul Baxter, Alex Martelli and Danil Suits. </p><p class="P118">Henk Uijterwaal has compiled his version under Linux (2.0.x and 2.2.x) without any problem, except that one needed to do: </p><p class="P174">ln -s /usr/bin/flex /usr/bin/lex </p><p class="P118">as flex has succeeded lex on Linux. On Ultrix, DEC Alpha(OSF), BSDI/3.x and SGI, the program compiled without any problem. </p><p class="Text_20_body"><span class="T8">A. Martelli </span><a href="mailto:alex@magenta.com" class="Internet_20_link"><span class="T8">(alex@magenta.com)</span></a><span class="T8"> used to build and run Dealer on Win/NT and Win/98 with the free Cygwin GCC C/C++ compiler and Unix emulation environment. Main changes needed were byacc instead of yacc, as well as flex instead of lex, in the Makefile. A Makefile with all these changes is available in the MSDOS subdirectory. </span></p><p class="P118">Dealer's latest versions build and run fine using Microsoft Visual Studio 5 and 6 (still using byacc and flex if needed for syntax mods, but with no other known dependency on Cygwin); there is a current dependency on the Winsock2 DLL (for ntohs, ntohl functions) soon to be removed. </p><p class="P119">&lt;/end Quote&gt;</p><p class="P116">Even in 1999, the last date I have for when work was done on this program by Henk Uijterwaal and others, the Linux kernel was still only in version 2.2.</p><p class="P116">It is now 2022, <span class="T55">so I, </span>JGM, have decided to use any Linux based tool that seemed appropriate without worrying too much about p<span class="T25">or</span>tability. I only started my modifications for my own learning and needs and never expected to release this code<span class="T55">, and it is too late  now to worry about p</span><span class="T138">or</span><span class="T55">tability.</span></p><p class="P116"> </p><h1 class="P209"><a id="a__Novice's_Introduction_to_Bison_Yacc_and_Flex"><span/></a><a id="__RefHeading___Toc3498_643984236"/>Novice's Introduction to Bison/Yacc and Flex</h1><h2 class="P228"><a id="a__Overview"><span/></a><a id="__RefHeading___Toc3500_643984236"/>Overview</h2><p class="P120">This bit is a 50<span class="T201">,</span>000 foot view of Bison and Flex. Written by a novice, for novices. If you really want to understand the theory behind how Bison generates its parsers, you need to read up on Compiler Design and LALR(1) grammars and so forth.</p><p class="P120">YACC stands for Yet Another Compiler Compiler and is a tool to help people write compilers for new languages that they come up with. The original author of Dealer, Hans van Steveren<span class="T142"> </span>(HvS) used YACC in a clever way to develop a parser for the dealer input file commands. It's not quite a compiler, but it is a very powerful parser.</p><p class="P120">So the overall process is this:</p><p class="P120">Define your 'language'. A language has a syntax and a grammar. Express your grammar in 'rules' that YACC understands. When you feed these rules into YACC it will produce a piece of magic C code that will parse your input for you. This piece of C code is a procedure called <span class="T19">yyparse().</span><span class="T45"> </span><span class="T27">The grammar definition is usually in a file with a </span><span class="T45">.y</span><span class="T27"> extension.</span></p><p class="P123">You also define your rules for making tokens that you feed into the parser. You process these token making rules with <span class="T43">Flex</span> and it produces a piece of not quite so magic C code that will break your input stream up into tokens. The lexer definition rules are usually in a file with a <span class="T43">.l</span> extension.</p><p class="P123">You then write a main program which calls <span class="T43">yyparse</span><span class="T46">()</span> to parse the input, and your main program then does whatever is called for with what yyparse produces. Usually there will be significant extra code required over and above just the parsing step, but not always. The GNU <span class="T41">B</span>ison examples have a main program that just calls yyparse and nothing else.</p><p class="P120">yyparse works by assembling 'tokens' into something more complicated; in the case of a parser that is say building sentences, the tokens are words. The bison examples on the GNU web site are various forms of calculators; the tokens are arithmetic operators, variable names, numbers, and so forth.</p><p class="P121"><span class="T19">yyparse</span><span class="T20">()</span><span class="T43">,</span> the parser,  gets its tokens by calling a C procedure named<span class="T224"> </span><span class="T21">yylex()</span><span class="T11">, </span>the lexer.<span class="T32"> (Lexing is short for 'lexical analysis' which is essentially breaking text up into its component parts.)</span></p><p class="P122"><span class="T26">yylex's job is to read the input stream and break it up into tokens according to certain rules. In the case of sentences the </span><span class="T27">tokens </span><span class="T26">are </span><span class="T27">groups</span><span class="T26"> of letters between whitespace and punctuation</span><span class="T27"> i.e. words</span><span class="T26">. In the case of the </span><span class="T27">calculators the tokens are numbers and symbols and so on. </span></p><p class="P123">You can run yyparse() as produced by bison, without involving flex to produce your lexer. If your lexer is simple enough you can code it by hand. In fact that is what the bison examples on the GNU web site do; they do not use flex at all.</p><p class="P123">You can also run your lexer without involving  a parser if your grammar is simple enough; i.e. you can in effect write your parser by hand. That is what some of the examples in O'Reilley's lex and yacc book do.</p><p class="P123">But usually you use the two of them together as a pair. Bison to produce the parser,<span class="T19"> yyparse</span><span class="T43">, </span>and Flex to produce the lexer,<span class="T19"> yylex.</span><span class="T29"> Using these programs rather than hand coding</span><span class="T142">,</span><span class="T29"> leads to fewer bugs, quicker development, and much easier maintenance. And the performance is on par with what you could write by hand. </span></p><h2 class="P228"><a id="a__The_Lexing_Process_--_Flex"><span/></a><a id="__RefHeading___Toc3502_643984236"/>The Lexing Process -- Flex</h2><p class="P123">The lexer's job is to produce tokens for the parser to assemble into something more elaborate. Each token always has an 'ID' associated with it, this is the token type. For example a string of digits might have the token type INTNUM, a string of digits with a decimal point could have the token type FLTNUM. A word could have the token type NOUN or VERB or CONJUNCTION.</p><p class="P123">Typically in the code we write we express token types in all capitals; other symbols that are made up of several tokens put together are in lower case. </p><p class="P123">In addition to its type, most tokens also have 'semantic value'. For a VERB say the semantic value would be something like, "does", "is", "has" and so forth; a FLTNUM could have a semantic value of 3.14159 or 2.7182818 say. When the lexer is returning the token to the parser it returns the token type as the value in the return <span class="T28">statement</span>, and it puts the semantic value into a global variable that is shared between the lexer and the parser. In the case of bison, this global variable is called <span class="T43">yylva</span>l, so flex puts the semantic value of the token type it is returning there.</p><p class="P124"><span class="T27">Not all tokens have a sema</span><span class="T55">n</span><span class="T27">tic value attached; for example in a calculator one of the tokens might be a plus sign,  '+'  </span><span class="T28">; </span><span class="T27">this plus sign has no semantic value</span><span class="T28">,</span><span class="T27"> it's just a token. </span></p><p class="P123">These two pieces of information are the main ones; you can build your application with nothing more. However a compiler (which is what bison/yacc is helping you build) is expected to provide diagnostic error codes and messages, and so the location of the token in the input stream, line and column numbers say, could be very useful. Flex and Bison have a way of sharing the location of the various tokens between them to help with such issues. </p><p class="P125">The lexer can also process certain tokens on its own; if the token does not need to be assembled into a more complicated structure<span class="T143">, </span> the<span class="T30">n</span>  having the 'front end' lexer handle what it can<span class="T55">, </span> can simplify the grammar and speed<span class="T30"> up the parser.</span></p><p class="P125">An example is comments; if the parser is just going to ignore the comments anyway, then the lexer might as well just skip over them itself. Another example in the <span class="T198">D</span>ealer program is the token 'produce'. This token specifies the maximum number of hands that meet the criteria, the <span class="T198">D</span>ealer program output. When the parser sees this token it takes its sema<span class="T55">n</span>tic value and puts it into a global variable that the main procedure will refer to later. But there is no need to involve the parser in such a simple task, the lexer already knows the semantic value of the number associated with the 'produce' word, and can easily populate the global variable itself.</p><h3 class="Heading_20_3"><a id="a__The_Lexing_Rules_File___l_"><span/></a><a id="__RefHeading___Toc3504_643984236"/>The Lexing Rules File (.l)</h3><p class="P125">The input to the flex program, the dot ell file, is essentially a set of lines that follow the model:</p><ul><li><p class="P241" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span><span class="T8">Column 1:</span> Pattern aka Regular Expression<span class="odfLiEnd"/> </p></li><li><p class="P243" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Whitespace<span class="odfLiEnd"/> </p></li><li><p class="P242" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>{ C code between curly braces that says what action to take when the pattern is matched. }<span class="odfLiEnd"/> </p><p class="P244" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm"><!-- --></span>Here is an example  of a Flex specification.<span class="odfLiEnd"/> </p></li></ul><p class="P6"><span class="T1">        </span>[0-9]+{ws} <span class="T11">{</span> yylval = atoi(yytext) ; return INTNUM ; <span class="T11">}</span></p><p class="P126">This says that when you see one or more digits with some whitespace following them, use the C function "<span class="T56">atoi</span>()" to convert the text you just matched to an integer; put the integer value into the global value yylval and return the token type INTNUM to yyparse. </p><p class="P127"> </p><p class="P127">That is the essence of a lexer specification; of course users want the ability to do more than just this, and <span class="T198">F</span>lex has many features designed to allow writing powerful lexer specs easily and quickly.</p><p class="P128">Flex takes specifications such as the above and produces a Finite State Machine that matches the input patterns, breaks the input text up into tokens, takes the corresponding actions, and passes the token type and semantic value to the parser. The name of the C procedure that does this job is <span class="T43">yylex()</span><span class="T88">.</span> As stated ea<span class="T88">r</span>lier while it is possible to generate a lexer by hand, it is quicker and easier to maintain, if you use a tool such as Flex to do it. It's the difference between writing declarative statements and procedural ones.</p><h2 class="Heading_20_2"><a id="a__Generating_The_Parser_with_Bison"><span/></a><a id="__RefHeading___Toc3506_643984236"/>G<span class="T31">enerating The Parser with Bison</span></h2><p class="P128">In order to build an application using a language, one needs to parse it. Many years ago, defining new languages was quite common; so someone at Bell Labs, where Unix, C, and many other software tools were invented, wrote the program Yacc, which stood for, "Yet Another Compiler Compiler'. This tool was designed to help people write compilers. The GNU re-implementation of Yacc, is Bison.</p><p class="P128">Bison, like Yacc before it, will take a series of declarative statements that define a language gramm<span class="T41">a</span>r, and it will produce an 'automaton' (State Machine) that can parse 'programs' written in that language.</p><p class="P129"><span class="T31">The name of the C procedure that does the parsing is </span><span class="T12">yyparse().</span><span class="T34"> yyparse calls a lexer, most often </span><span class="T14">yylex()</span><span class="T34"> whenever it needs a token. Then using the context established by previous tokens, and the rules defined in the grammar, the parser can either process the user's input itself (see the various GNU calculator examples) or, in the case of our </span><span class="T39">D</span><span class="T34">ealer program, it creates some data structures (decision tree, and action list) that the main program uses to generate bridge hands of interest.</span></p><p class="P129"><span class="T34">The parser's job is considerably more complex than that of the lexer. The author of the dealer program, Hans van St</span><span class="T40">a</span><span class="T34">veren, was very clever in his use of the lex and </span><span class="T39">yacc</span><span class="T34"> tools to build this application. </span></p><h3 class="Heading_20_3"><a id="a__The_Parsing_Rules_File___y_"><span/></a><a id="__RefHeading___Toc3508_643984236"/>The Parsing Rules File (.y)</h3><p class="P130">The file that defines the grammar and the token types  typically has a dot wye extension. There are several good examples of such files on the GNU web site in the Bison documentation section.</p><p class="P130">One of the things about grammar rules is that they are usually recursive; it is extremely common to see rules that read, "An expression is either a number, or an expression in parentheses, or an  expression<span class="T143"> followed by </span>the character '*' and another expression".  You can see that the expression is defined in terms of itself, like recursive function calls in many programming languages.</p><p class="P131">To really understand how a parser automaton is generated and works you need to read up on compiler design, LALR(1) grammars, shift / reduce parsing and so on. That is well beyond what I can go into here, but the GNU Bison site is an excellent place to start.</p><p class="P131">We turn now to the dealer program itself. </p><h1 class="P224"><a id="a__Overview_of_the_Operation_of_Dealer"><span/></a><a id="__RefHeading___Toc3510_643984236"/>Overview of the Operation of Dealer</h1><p class="P134">The current production version of Dealer, has good documentation on how to use the program, what words and specifications you can put in the input file and so on. But the <span class="T198">D</span>ealer documentation is pretty sparse when it comes to describing how the program works, so that those who want to modify or extend it really have to study the code.<span class="T136"> As explained in the prologue, the following is what I have learned from extending Dealer's functionality.</span></p><p class="P135">The program can be thought of as consisting of 4 main parts:</p><p class="P135">1. Initialization and setup. This portion also processes any options entered on the command line. JGM in version 2.0 has almost doubled the number of parameters that can be passed into <span class="T136">D</span>ealer this way.</p><p class="P135">2. Calling <span class="T19">yyparse()</span>. This step processes the user's input file and builds several 'trees' and linked lists in memory that tell <span class="T136">D</span>ealer how to generate deals that are 'interesting' to the user.</p><p class="P135">3. Setting Context. This step is a sort of initialization part II. Some of the results produced by yyparse, are over-ridden by the parameters passed in on the command line. </p><p class="P135">4. The Main Loop. This bit consists of several parts.</p><p class="P175">4.1 Use a random number generator to shuffle a deck of cards. </p><p class="P175">4.2 For each deal generated in 4.1 walk the decision tree produced by the yyparse stage to see if the deal is 'interesting'. An 'interesting' deal is one that satisfie<span class="T136">s</span> the <span class="T43">condition</span> as defined in the input file. This step is explained in more detail later in this document<span class="T198">.</span> If the deal is interesting, proceed to step 4.3. If the deal is not interesting  discard it and return to step 4.1</p><p class="P176">4.3 If the deal is interesting then run through the list of 'actions' defined by the user and perform them. Most actions involve producing some form of output, usually via a print statement. Many times there is only one action statement such as <span class="T19">printall</span> (the default action). Actions are of two types, those that produce output for every interesting deal, and those that produce output only at the end of the run. Examples of the first kind are the <span class="T13">p</span><span class="T11">rintall</span>, or <span class="T11">printoneline</span> actions. Examples of the second kind are the <span class="T13">a</span><span class="T11">verage</span> and <span class="T13">f</span><span class="T11">requency</span> actions. It not usually useful to have more than one action that produces output for every deal as the output<span class="T1">(s)</span> from them would all <span class="T33">be</span><span class="T11"> </span>mixed together. But it is quite useful to have one action that produces output for every<span class="T89"> </span>deal, and several other actions that wait till the end of the run to produce their output, such as several Averages, or Frequency counts.</p><p class="P177">4.4 The Main Loop finishes when either the Generate or the Produce count is reached, whichever comes first.</p><p class="P184">5. The end of the run processing. </p><p class="P185"><span class="T144">        </span><span class="T136">After finishing the main loop, D</span><span class="T144">ealer outputs the results of the delayed actions, the Averages, the Frequency Counts, the Print Compass and the Evalcontract. If the user has left the verbose mode </span><span class="T143">set to ON</span><span class="T144"> it also outputs the time taken and the total number of deals generated and produced, one of which will be less than the user asked for. </span></p><p class="P184"> </p><p class="P184"> </p><h1 class="P212"><a id="a__Evaluating_the_Condition_Clause"><span/></a><a id="__RefHeading___Toc3512_643984236"/>Evaluating the Condition Clause</h1><p class="Standard"><span class="T91">Evaluating the condition clause is the most complex part of </span><span class="T92">what Dealer does. For one thing there are very many aspects of a bridge hand, or deal, that the user may wish to use as a selection criteria. These aspects include such things as: suit lengths, high card points, controls, shape and many others.  They can be combined into complex expressions with each other,  using many of the standard arithmetic operators such as plus, minus, division and multiplication. The complex expressions can be further combined into logic clauses with standard logic predicates such as 'not', 'and', 'or', and 'if'. See the user's documentation for details. </span></p><p class="P1">The parser will assemble the various key words and functions in the input file into a series of 'clauses' known in this instance as 'rules'. Whenever the parser has assembled enough tokens from the lexer to make up a rule, it executes the C code that the programmer has specified for that rule. <span class="T116">It is Yacc/Bison, the parser generator, that is responsible for generating the C code that manages to keep the rules coherent and in a logical sequence. The programmer does not need to know</span><span class="T225"> how</span><span class="T116"> it does this. So long as he has specified a grammar with no 'bugs' in it, Yacc/Bison will generate a correct parser. </span></p><p class="P2"> </p><p class="P2">In Dealer the usual 'user action' that is taken when a <span class="T199">condition </span>'rule' is recognized is to add a 'node' to the decision tree.  A diagram of a simple decision tree is shown on the next page.  The programmer does not have to try to ensure that the new node is added in the right place on the tree. That is the parser's job. The programmer just has to make sure that the node is the correct type <span class="T117">and also that whatever values are needed at runtime are part of the data carried with the node.</span></p><p class="P19"><span class="T117">In the following diagram, each node has: i) a type always present, ii) two integer values that are part of the node structure; </span><span class="T137">one, none</span><span class="T117">, or both of these may be used; and iii) two pointers again 0, 1, or both of these may be used to point to child nodes of the current one. </span></p><p class="P3"> </p><p class="P3"><span class="T137">As an example, </span><span class="T188">when </span><span class="T137">t</span>he following condition expression<span class="T137">:</span><span class="T134"> </span></p><p class="P7"><span class="T118">c</span>ondition ( (<span class="T188"> </span>hcp(west) + hcp(east) ) <span class="T188">    </span>&gt; 25 &amp;&amp; </p><p class="P7"><span class="T188">            </span>(hearts(west)<span class="T188"> </span>+<span class="T188"> </span>hearts(east)<span class="T188">)</span> &gt;= 9 &amp;&amp; </p><p class="P7"><span class="T188">          </span><span class="T235"> </span>shape(west, any 7xxx )<span class="T188"> </span>&amp;&amp;<span class="T118"> </span> dds(west, hearts) &lt; 10 )</p><p class="P56"><span class="T188">is</span><span class="T134"> parsed by the yacc/bison generated yyparse() function </span><span class="T135"> a 'decision tree'</span><span class="T188"> is created</span><span class="T135"> in memory at run time. This is done once while the input file is being parsed, and is used for the rest of the run.</span><span class="T143"> On the next page is a diagram of what the decision tree looks like. </span><span class="T135"> In the diagram the type of node is shown inside the circle, the values attached to the node are shown in the rectangular boxes, and the links between the nodes by straight lines. </span></p><p class="P57">The evaluation function recursively calls itself<span class="T259">; It starts at the top of the tree, but the top node in the tree needs the result from the next two nodes down. So the evaluation function calls itself on first the left  node, and then the right node. And each call to those nodes, evaluates sub-nodes and so on. T</span>he effect is that the decision tree is evaluated left to right bottom to top. <span class="T188">This is pretty much the same order as the clauses appear in the condition statement. </span><span class="T134">T</span>his <span class="T134">fact </span>will have some practical value as will be explained later. </p><p class="P57">As soon as the evaluation function can make a decision, it does so and it does not continue to evaluate all the nodes <span class="T119">if it is not necessary. </span></p><p class="P58"><span class="T119">In this example there are many clauses joined by '</span><span class="T192">and</span><span class="T119">' </span><span class="T188">therefore</span><span class="T119"> as soon as one of the branches of an 'and' is false the whole </span><span class="T137">expression </span><span class="T119"> must be false and the evaluation function can finish.</span><span class="T145"> </span></p><p class="P3"> </p><!--Next 'div' was a 'text:p'.--><div class="P197"><!--Next 'div' is emulating the top height of a draw:frame.--><div style="height:2.6711cm;"> </div><!--Next '
            div' is a draw:frame.
        --><div style="height:0.2571in;width:0.3622in; padding:0;  float:left; position:relative; left:9.338100000000001cm; " id="Shape2_3" class="P258"><!--Next 'div' was a 'draw:text-box'.--><div style=""><p><span class="T270">  </span><span class="T270">&amp;</span></p></div></div><!--Next 'div' is emulating the top height of a draw:frame.--><div style="height:0.808cm;"> </div><!--Next '
            div' is a draw:frame.
        --><div style="height:0.2571in;width:0.3622in; padding:0;  float:left; position:relative; left:9.966900000000001cm; " id="Shape2_4" class="P258"><!--Next 'div' was a 'draw:text-box'.--><div style=""><p><span class="T270">  </span><span class="T270">&amp;</span></p></div></div><!--Next 'div' added for floating.--><div style="position:relative; left:9.966900000000001cm;"/><!--Next 'div' is emulating the top height of a draw:frame.--><div style="height:2.381cm;"> </div><!--Next '
            div' is a draw:frame.
        --><div style="height:0.2669in;width:0.3335in; padding:0;  float:left; position:relative; left:11.8529cm; " id="Shape3" class="P257"><!--Next 'div' was a 'draw:text-box'.--><div style=""><p>  &lt;</p></div></div><!--Next 'div' added for floating.--><div style="position:relative; left:11.8529cm;"/><!--Next 'div' is emulating the top height of a draw:frame.--><div style="height:8.213100000000001cm;"> </div><!--Next '
            div' is a draw:frame.
        --><div style="height:0.2669in;width:0.3335in; padding:0;  float:left; position:relative; left:3.8219cm; " id="Shape3_5" class="P257"><!--Next 'div' was a 'draw:text-box'.--><div style=""><p>  #</p></div></div><!--Next 'div' added for floating.--><div style="position:relative; left:3.8219cm;"><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p>                                Example Decision Tree</div></div><div style="clear:both; line-height:0; width:0; height:0; margin:0; padding:0;"> </div><div class="P4"/><p class="P4"> </p><div class="P4"><p> </p></div><!--Next 'div' was a 'text:p'.--><div class="P4"><!--Next 'div' is emulating the top height of a draw:frame.--><div style="height:0.3259cm;"> </div><!--Next '
            div' is a draw:frame.
        --><div style="height:0.5122in;width:0.4394in; padding:0;  float:left; position:relative; left:11.0071cm; " id="Shape3_2" class="P257"><!--Next 'div' was a 'draw:text-box'.--><div style=""><p> <span class="T270">Shape</span></p></div></div></div><div style="clear:both; line-height:0; width:0; height:0; margin:0; padding:0;"> </div><div class="P4"/><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P4"> </p><p class="P5">Since the evaluation is done left to right, roughly in the same order as specified in the condition statement, it pays to put the quicker evaluations first; if these fail the evaluation routines may never have to execute the slower functions. In this example the DDS <span class="T202">(Double Dummy Solver) </span>function is the slowest, since it is more difficult to calculate the number of tricks a hand can take than to count its hcp or the number of cards in a suit. So we put it last in the condition statement; had we put it first, it would have been called on every deal<span class="T137">. As</span> shown it is called only for those deals which meet all other conditions.</p><h1 class="P225"><a id="a__Code_Locations_--_src_Directory"><span/></a><a id="__RefHeading___Toc3514_643984236"/>Code Locations<span class="T206"> -- src Directory</span></h1><p class="P136">JGM has <span class="T122">(re)-</span>organized the C code that makes up the <span class="T137">D</span>ealer application as follows:<span class="T123"> (all</span><span class="T137"> </span><span class="T123">of the following are in the "</span><span class="T44">src</span><span class="T123">" directory.</span></p><p class="P136"><span class="T43">dealflex.l</span> - there is some C code here that implements Flex action statements and some functions that are called by these action statements.<span class="T137"> This file also contains the lexing rules for Flex. </span><span class="T250">The .l file is much more complex than that for Dealer version 1. The reason is that Version 2 makes use of Flex's ability to redirect the input stream from the .l file itself to a string variable; in effect it calls itself recursively and pushes the current state on a stack. Version 2 uses this feature to implement the scripting variables, and the FD shapes. </span></p><p class="P136"><span class="T43">dealyacc.y </span>- there is some C code here that is run whenever the parser 'reduces' a rule; typically this C code adds a node to the decision tree or adds another item to the action list or the variable list. There is also C code that consists of functions that are called by the tree building statements in the rules.<span class="T137"> This file also contains the grammar definition for the Dealer application.</span></p><p class="P137"><span class="T43">dealer</span><span class="T50">v2</span><span class="T43">.c </span>- This file includes the <span class="T122">"</span>main<span class="T122">"</span> function<span class="T122">, the</span> initialization<span class="T122">, and the</span> main<span class="T122"> </span>loop code.</p><p class="P137"><span class="T43">mainsubs.c</span><span class="T51"> </span><span class="T120">- this code is used by the main program to parse command line variables, initialize the random number generator and so forth.</span></p><p class="P136"><span class="T43">dealparse_subs.c</span> - These are more extensive routines that are run during the parser phase of Dealer. They do not implement evaluation or bridge oriented functionality; they do not form part of the main loop code.<span class="T121"> The are primarily called from code in the dealflex.l and dealyacc.y files.</span></p><p class="P136"><span class="T43">dealeval_subs.c</span> - These functions are run during the evaluation phase of the main loop. That is they are run for every random hand that Dealer generates. These functions make up the code that is run depending on which node of the decision tree  is being traversed.</p><p class="P140"><span class="T43">c4.c</span><span class="T121">        - This code implements the Kaplan and Rubens Four C's hand evaluation method, as well as the Suit Quality measurements. The code is run during the evaluation phase but it is in its own file to make it easier to maintain.</span></p><p class="P139"><span class="T43">dealdds_subs.c</span><span class="T121"> - This code implements the calls to the Double Dummy Solver library. It is run during the evaluation phase, but the functions have been given their own file to make them easier to maintain.</span></p><p class="P140"><span class="T43">Dealer_DDS_IF.c</span><span class="T121"> - This code provides the interface between Dealer and the DDS library. It is in its own file to avoid name conflicts with code in the other dealer files. </span></p><p class="P138"><span class="T43">dealaction_subs.c</span> - These functions are run when the evaluation phase marks the deal as interesting. They implement the print, average, frequency and such like functionality.</p><p class="P139"><span class="T43">dealdebug_subs.c</span><span class="T52"> </span><span class="T122">- These are functions written by JGM to debug his code and to learn how Dealer works.  Unless the symbol JGMDBG is defined at compile time, they should have no effect on the operation of </span><span class="T137">D</span><span class="T122">ealer. </span></p><p class="P172"><span class="T53">dealServer</span><span class="T43">_subs.c </span>- These functions implement the usereval functionality<span class="T252"> in Dealer</span>. They start and stop the external server program, create the IPC semaphores, and shared memory (mmap) area,  and perform the asking of the query(s) and the reporting of the responses. <span class="T252">They do not implement the code for the external server itself.</span></p><p class="P170">There is also a sub-directory called, <span class="T43">UserEval</span>. In this directory are the files that implement the server infrastructure, and the various metrics calculations.  These next files are in this sub-directory.</p><p class="P169"><span class="T53">U</span><span class="T49">s</span><span class="T53">erServer</span><span class="T49">.c</span><span class="T251"> - This file contains the code for the external server. It includes the functions to mmap the shared memory area, signal with the semaphores, retrieve the query from the mmap, and write the responses thereto. It also calls the 'userfunc' </span><span class="T260">code </span><span class="T251">that implements the measurements that the user wants. </span></p><p class="P171">metrics_calcs.c, factors_subs.c, metrics_util_subs.c<span class="T124">-  These files contain code that is called by </span><span class="T133">Dealer</span><span class="T124">Server to actually perform the calculations. The idea is that the user can write his own code to calculate whatever he likes, and then compile and link it with UserServer.c, thus focussing on his own code and not having to worry about the infrastructure of how to share memory, or communicate via semaphores. There are many examples of how to use the usereval keyword to post the query and use the reply.</span></p><h1 class="Heading_20_1"><a id="a__Code_Locations_--_include_Directory"><span/></a><a id="__RefHeading___Toc29072_2914024446"/><span class="T132">C</span><span class="T207">ode Locations</span><span class="T206"> -- include Directory</span></h1><p class="P142">The header files are in the <span class="T43">"include"</span> directory</p><p class="P141"><span class="T43">std_hdrs.h</span> - this file contains include statements for  all the standard headers needed, such as stdlib.h, stdio.h, assert.h etc. The first statement in this file is to define the macro _GNU_SOURCE. This has the effect of 'turning on' all the GNU extensions that are available <span class="T199">in </span>glibc, such as extra string functions and so on. If you want strictly POSIX or strictly ANSI C, you will need to define a different macro.</p><p class="P141"><span class="T43">dealdefs.h </span>- this file defines all the symbolic constants used. It is needed by all the other .h files as well as most of the .c files.</p><p class="P141"><span class="T43">dealtypes.h</span> - this file defines the various structures, arrays, typedefs and so on. It uses the definitions from dealdefs.h</p><p class="P141"><span class="T43">dealglobals.c</span> - This file defines and allocates space for the global variables used in <span class="T246">D</span>ealer. There are probably too many of these, but several are used to exchange information between Flex, Yacc, and the Dealer main program, as well as between functions compiled in different files. This file should only be included in the main program file, dealer<span class="T202">v2</span>.c, not in any of the other files.</p><p class="P141"><span class="T43">dealexterns.h</span> - This file is the counterpart to dealglobals.c. It contains <span class="T43">extern  </span><span class="T124"> statements for the global variables defined in dealglobals.c</span></p><p class="P160"><span class="T43">dealprotos.h</span> - This file contains prototype statements for most of the functions that are not defined in the same file where they are used. </p><p class="P161">The above files are usually all that is needed by most of the <span class="T202">D</span>ealer .c files. In addition there are a few files that are only needed by a small subset of the code:</p><p class="P161"><span class="T43">c4.h </span>- header info used only by the c4.c file, and defining an interface to that code.</p><p class="P161"><span class="T43">deal_dll.h</span> - this file is an extract from the dll file provided with the DDS library. It imports the minimum amount of information to avoid potential naming conflicts.</p><p class="P161"><span class="T43">deal_dds.h</span> - this file makes available to the code that uses the DDS library the minimal amount of information from the Dealer program.</p><p class="P161"><span class="T43">pointcount.h</span> - included into dealtypes.h because it defines the max size of the pointcount array.</p><p class="P166"><span class="T48">deal</span><span class="T47">debug_subs.h</span><span class="T125"> - some prototypes and definitions for the debugging routines.</span></p><p class="P166"><span class="T47">mmap_template.h</span><span class="T49"> </span><span class="T131">- The structs and other definitions used by the usereval_subs, and the user_eval server. </span></p><p class="P162"/><h1 class="Heading_20_1"><a id="a__Code_Locations_--_Other_Directories"><span/></a><a id="__RefHeading___Toc29074_2914024446"/><span class="T125">Code Locations</span><span class="T126"> -- </span><span class="T7">Other</span><span class="T126"> Directories</span></h1><p class="P63">The <span class="T56">Prod </span>directory contains the Makefile and the binary for the 'production' version of <span class="T43">dealerv2</span>.</p><p class="P63"> </p><p class="P64">The <span class="T56">Debug</span> directory contains the Makefile and the binary for the debug version of Dealer, <span class="T43">dealdbg</span></p><p class="P64"><span class="T226">There is also a</span> <span class="T43">DebugExamples</span> directory for testing various mods to Dealer. <span class="T210">In </span><span class="T226">Debug/Makefile</span><span class="T210"> the symbol JGMDBG is defined, so that the debugging code in the Dealer source files is included in the resulting binary. The included debugging code is triggered by setting the -D switch on the cmd line to a value between 1 and 9. If the -D switch is set to 0 then all the debugging output is suppressed.</span><span class="T226"> Debugging output is sent to </span><span class="T82">stderr</span><span class="T226"> so that it is possible to save the debugging output by redirecting </span><span class="T82">stderr</span><span class="T226">, and not have it interfere with the normal Dealer output.</span></p><p class="P63"> </p><p class="P63"><span class="T208">T</span>he <span class="T56">docs</span> directory contains the User Guide, a README file, this Maintainer's guide<span class="T208">, license and copyright files, </span>and other useful background info.</p><p class="P64"> </p><p class="P64">The <span class="T56">lib</span> directory contains the pre<span class="T210">-</span>compiled DDS library. <span class="T209">This is a static library, NOT a shared object.  I hope that this means it will not be necessary to recompile it for different Linux kernels. </span>While Dealer itself can be compiled with ordinary C compiler, DDS must be compiled with C++. Since this library was compiled with g++ the final dealerv2 binary link step must be done with g++. The Makefiles have been pre-built to do this.</p><p class="P64">lib also contains a tarball of the JGM's Perl code that implements the Optimal Point Count hand evaluation method. This code is needed if you intend to use the 'opc' functionality of Dealer. </p><p class="P64">There is no 'package' install of this, but Dealer has been pre-compiled to run the code from the /usr/local/bin/DOP directory. You will need super-user priviledges to install it in that location.</p><p class="P83">lib also contains François' Perl script that parses the enhanced shapes syntax. </p><p class="P64"> </p><p class="P63">The Examples directory contains many Dealer 'Input Files' demonstrating how to use the various features of Dealer. Many of these come from the original version. <span class="T208"> There are also files giving the output  from these examples on my machine, and a </span><span class="T236">P</span><span class="T208">erl script to compare the latest output to the reference output. This has been copied from version 1. </span></p><p class="P63"> </p><p class="P64">The DDS directory contains <span class="T209">a tarball of Bo Haglund</span><span class="T252">'</span><span class="T209">s Double Dummy Solver.</span></p><p class="P65">If you intend to rebuild this library it is best to start with BH's distribution, but you might find some of the files in this directory helpful. </p><h1 class="P214"><a id="a__Modification_Examples"><span/></a><a id="__RefHeading___Toc3516_643984236"/>Modification Examples</h1><h2 class="P229"><a id="a__Adding_a_Title_"><span/></a><a id="__RefHeading___Toc3518_643984236"/>Adding a Title.</h2><p class="P20">The objective is to be able to add a title string to some of the output, so as to describe<span class="T141">, for example,</span> what bidding practice is being generated. One can also put this title out as part of the PBN report.</p><p class="P20">The title will be a simple character array in a global variable. As such there is no real grammar associated with this; we can do it all in the Flex file. </p><p class="P20">1. Allocate space for the title string, and its length in the <span class="T190">dealglobals.c</span> file.  Also add an extern definition for these global variables in the <span class="T190">dealexterns.h</span> file.</p><p class="P20">2. In the <span class="T190">dealflex.l</span> file define the patte<span class="T199">rn</span> 'title' beginning in column 1. <span class="T139">We could make a regex that </span><span class="T139">matches 'title' followed by whitespace then followed by a quoted string. But we want the user to be able to put the title on a separate line. So we make use of Flex's "exclusive state" feature so that once 'title' is seen the only thing that Flex will recognize is a quoted string.  The user action statement associated with the quoted string, copies the string to the global variable, and also sets the length. It then exits the exclusive state an</span><span class="T141">d</span><span class="T139"> resumes looking for a token that it can pass to yyparse.</span></p><p class="P66">Here is the code as it is in the<span class="T43"> dealflex.l</span> file:</p><p class="P8">%x TITLE</p><p class="P8">ws [ \t]+</p><p class="P8">nl \n</p><p class="P8">qstring   \"[^\"\n]*[\"\n]</p><p class="P8">title({ws}|{nl}) { BEGIN(TITLE);  }</p><p class="P8">&lt;TITLE&gt;{nl}   ;                /* do nothing if {nl} found. */</p><p class="P8">&lt;TITLE&gt;{qstring}  {</p><p class="P8">                    strncpy(title, yytext+1, (yyleng-2) ) ;</p><p class="P8">                    title[yyleng-2] = '\0';</p><p class="P8">                    title_len = strlen(title) ;</p><p class="P8">                    BEGIN(INITIAL) ;</p><p class="P8">                  }</p><p class="P21">The first <span class="T140">line defines a new exclusive state to Flex. </span></p><p class="P21"><span class="T140">The next </span>3 lines just define some symbolic constants to make reading the rest of the code easier.</p><p class="P59"><span class="T101">The line beginning with 'title' </span><span class="T102">tells Flex to </span><span class="T101">look for </span><span class="T93">'</span><span class="T101">title</span><span class="T93">'</span><span class="T101"> followed by whitespace,  or newline. If it sees that, it enters the </span><span class="T103">TITLE exclusive state, looking only for a quoted string. <br/>When </span><span class="T102">Flex</span><span class="T103"> finds a quoted string it copies the text it found (less the opening and closing quote marks) to the global variable and adds a null string terminator at the end.</span></p><p class="P22">Then for convenience it saves the length of the string in another global variable, and exits the TITLE state and returns to the default, INITIAL state. </p><p class="P22"> </p><p class="P22">Other parts of the program can test the title_len variable and if it is non-zero they know that there is a title that can be output along with the Dealer results. If the user does not want a title mixed in with his output he does not enter one. </p><p class="P22"> </p><p class="P22">This is all done without involving the grammar file, <span class="T190">dealyacc.y</span><span class="T193">.</span></p><p class="P22"> </p><h2 class="P230"><a id="a__Adding_Losing_Trick_Count__ltc_"><span/></a><a id="__RefHeading___Toc3520_643984236"/>Adding Losing Trick Count (ltc)</h2><p class="P145">The next example adds a new feature to the Dealer vocabulary. I wanted to have a more 'modern' LTC than just counting losers. For example AJT should be counted as 1.5 losers not 2; Qxx should be counted as 2.5 losers not 2. In the input file the user would be able to enter conditions such as:</p><p class="P147">ltc(north)&lt;5.5 <span class="T90">or perhaps </span>ltc(north,spades)&lt;2<span class="T188">.</span> &amp;&amp; ltc(south, clubs)&lt;1<span class="T188">.</span></p><p class="P146"><span class="T93">You can see that this is very similar to the syntax of other aspects of hand evaluation such as </span><span class="T96">HCP</span><span class="T93">, or length in a suit. So the grammar would also be very similar to the </span><span class="T96">HCP</span><span class="T93"> grammar.</span></p><p class="P149">The steps involved are as follows:</p><p class="P149">I - Grammar file (<span class="T190">dealyacc.y</span>)</p><p class="P146">1. Define a new token LTC with a <span class="T56">%token</span><span class="T59"> LTC</span> statement.</p><p class="P145"><span class="T90">2. Write two new rules, the first to handle the case where the user enters only the 'compass' direction </span><span class="T96">[</span><span class="T90">e.g. </span><span class="T56">ltc(north)</span><span class="T96"> ] </span><span class="T90">and the second where the user enters the compass direction and the suit.</span></p><p class="P146"><span class="T93">3. In the action statement associated with reducing the first rule, create a new node of type TRT_LTCTOTAL and put the compass direction value (0..3) in the first integer </span><span class="T105">of</span><span class="T93"> the </span><span class="T105">node</span><span class="T93">.</span></p><p class="P145"><span class="T90">4. In the action statement associated with reducing the second rule, create a new node of type TRT_LTC</span><span class="T94">, put the compass value in the first integer, and the suit value in the second integer.</span></p><p class="P151"><span class="T94">5</span><span class="T95">. Bison will assign an integer value to the new token LTC when it builds the parser from the grammar file. Flex will become aware of this value via the  </span><span class="T57">#include dealyacc.tab.h </span><span class="T95">file which is generated from the grammar file along with the yyparse C code. In the dealflex.l file we tell Flex what to do when it sees an 'ltc' word:  </span><span class="T57">ltc    return(LTC)</span><span class="T58">;</span></p><p class="P151"><span class="T95">6. The next step is to write the code that will calculate the LTC values for various suit combinations. The code for this is in the </span><span class="T107">dealeval_subs.c </span><span class="T95">file.  The way Dealer is written</span><span class="T104">,</span><span class="T95"> after the random deal is generated, but before the decision tree is scanned, there is a routine called 'analyze' which pre-calculates several aspects of hand evaluation, such as High Card Points, suit lengths, controls</span><span class="T96">,</span><span class="T95"> in general any aspect of the hand which is likely to be needed on most deals, and which is relatively straightforward to derive. We </span><span class="T96">add to the</span><span class="T95"> 'analyze' function </span><span class="T96">a</span><span class="T95"> call </span><span class="T104">to </span><span class="T95">the function we write to calculate the new ltc.</span></p><p class="P151"><span class="T95">7. There is one aspect of the above which is not mentioned here, and that is the use of numbers with decimal points (such as 2.5 in the above example). Version 1 of Dealer had no notion of any number that was not an integer; all the calculations and all the return values were all integers. In version 2, JGM extended the Dealer syntax to allow the user to input numbers of the form 99.99 but internally Dealer remains an integer only application. See the </span><span class="T108">User Guide</span><span class="T95"> where the new 'Dotnum' feature of Dealer is described</span><span class="T96"> for the limitations of this feature.</span></p><p class="P150">Here is the code that has been added to the grammar file to implement the LTC feature. It is virtually identical to the code that defines HCP for example:</p><p class="P152"><span class="T90">       </span><span class="T56">| LTC '(' compass ')'</span></p><p class="P148">            { $$ = newtree(TRT_LTCTOTAL, NIL, NIL, $3, 0 ); }</p><p class="P148">   | LTC '(' compass ',' SUIT ')'</p><p class="P148">            { $$ = newtree(TRT_LTC,      NIL, NIL, $3, $5); }</p><p class="P167"><span class="T96">"$3" in the above refers to the value that has been assigned to 'compass'. "$5" refers to the value that has been assigned to "SUIT".  </span><span class="T97">Aside: $1 is LTC , $2 is the </span><span class="T99">(</span><span class="T100"> </span><span class="T97">left parens  and $4 is the comma in the second rule.</span><span class="T98"> </span></p><h1 class="P213"><a id="a__Random_Number_Generation"><span/></a><a id="__RefHeading___Toc3522_643984236"/>Random Number Generation</h1><p class="P153">The original author of Dealer, HvS, was quite conscious of the time taken to generate and analyze hundreds of thousands of deals in order to get  few hundred that would meet the user's criteria. For example the original dealer code had a very clever way of avoiding modulo division when generating a random number.  According to my tests HvS's method cut the time to generate a random number in half. </p><p class="P154"><span class="T146">The system on which </span><span class="T153">the following</span><span class="T146"> performance numbers were generated is as follows:</span></p><p class="Standard">System:   <span class="T200">   </span>Linux Kernel: 5.4.0-96-generic x86_64 bits: </p><p class="Standard">Machine:   Type: Desktop Mobo: ASUSTeK model: P8Z68 DELUXE </p><p class="Standard">CPU:       <span class="T200">  </span>Topology: Quad Core model: Intel Core i7-2600K bits: 64 type: MT MCP </p><p class="Standard">L2 cache: <span class="T200"> </span>8192 KiB </p><p class="Standard">Speed: <span class="T200">    </span>1605 MHz min/max: 1600/3800 MHz Core speeds (MHz):  4 CPUs, 8 Cores.</p><p class="Standard"> </p><p class="P30">Dealer itself was compiled with GCC version 9, with optimization level <span class="T147">-</span>O3<span class="T227">(Prod directory)</span> or </p><p class="P30"><span class="T236">-</span>Og<span class="T227">(Debug directory)</span>.</p><p class="P29"> </p><p class="P52"> </p><p class="P52">Random Number Generation:</p><p class="P36">Avg Random Number (0..100) over 10 million deals using rand : </p><p class="P36"><span class="T185">Average</span>=   49.48, St<span class="T185">d</span> Dev=   28.87, Var=    833.37, Sample Size=10000000 </p><p class="P36">10 Million Random Numbers</p><p class="P36">Generated 10000000 hands</p><p class="P36">Produced 10000000 hands</p><p class="P36">Initial random seed 138249490574914</p><p class="P31">Time needed   18.067 sec</p><p class="P29"> </p><p class="P54">Without the Debugging code and symbols, and using -O3 optimization the result is:</p><p class="P55">Avg Random Number (0..100): </p><p class="P55">Mean=   49.50, Std Dev=   28.87, Var=    833.23, Sample Size=10000000</p><p class="P55">Random Number Generator Test 10,000,000 No Conditions</p><p class="P55">Generated 10000000 hands</p><p class="P55">Produced  10000000 hands</p><p class="P55">Initial random seed 113</p><p class="P32">Time needed   12.773 sec</p><p class="P54"> </p><p class="P29">The original Version 1.4 code as distributed by Debian (and compiled on my machine with -O3) gives:</p><p class="P36">Avg Random Number (0..100) over 10 million deals using rand : 49.5036</p><p class="P36">Generated 10000000 hands</p><p class="P36">Produced 10000000 hands</p><p class="P36">Initial random seed 1643427436</p><p class="P31">Time needed    5.046 sec</p><p class="P34"> </p><p class="P35"><span class="T35">The difference is that in the first </span><span class="T38">two </span><span class="T35">case</span><span class="T38">s</span><span class="T35"> JGM has removed HvS's clever workaround </span><span class="T36">which</span><span class="T35"> sped up the RNG. The main reason being that I did not quite understand it; it seemed to me that this method (which is essentially 16 bit?) would result in a relatively short period for the RNG; my concerns were further amplified by HvS's statements that the RNG was the most dubious part of the program, and that the program was not suitable for generating deals for such things as tournament play. I wanted to use the current GNU 48 bit random number generator, (which was not available when Hans first wrote his program) and I wanted to be certain that the period of the RNG was sufficiently long for the simulation studies that I was doing. </span><span class="T37"> I figured I could afford a few extra micro-seconds to be certain.</span></p><p class="P33">If we assume that we will need 10,000 deals generated per <span class="T186">simulation </span>run, and each deal needs 52 random numbers for the shuffle, then we need 5.2*10<span class="T148">5 </span><span class="T151">random numbers per run. To avoid the 'birthday paradox' the period of the RNG should be greater than the square of this number or 27*2</span><span class="T149">33</span><span class="T151">. The period </span><span class="T151">of the 2022 GNU RNG is said to be 2</span><span class="T149">45</span><span class="T152">.  </span><span class="T151">In addition I have taken the precaution of seeding the RNG with values from the Linux Kernel's entropy pool to ensure as much randomness as possible. Of course the user still has the option of specifying an initial seed value as he could in previous versions.</span></p><p class="P39">For reference <span class="T200">it is the modulo division required to map the number generated by the RNG into the range 0 .. 52 that takes the extra time. T</span>he GNU RNG is not the source of the time taken; a program that does nothing but return <span class="T196">5</span>0 Million random numbers takes the following amount of time:</p><p class="P41">CheckRandom:: Version=DOUBLES, Seed=234021249433746</p><p class="P41">Average over 50000000 loops = 0.500036 </p><p class="P40">real<span> 0m0.376s<span class="T196">  </span>user</span><span> 0m0.375s<span class="T196">    </span>sys</span><span> 0m0.001s</span></p><p class="P40"> </p><p class="P40">CheckRandom:: Version=LONGS, Seed=47779911134368,  </p><p class="P40">Average over 50000000 loops = 1.07375e+09 </p><p class="P40">real<span> 0m0.295s<span class="T196">  </span>user</span><span> 0m0.289s<span class="T196">   </span>sys</span><span> 0m0.004s</span></p><p class="P40"> </p><p class="P44">The older GNU RNG gives these results:</p><p class="P42">CheckRandom:: Version=SHORTS, Seed=0,   </p><p class="P42">Average over 50000000 loops = 1.07376e+09 </p><p class="P42">real<span> 0m0.423s  user</span><span> 0m0.419s   sys</span><span> 0m0.004s</span></p><p class="P42"> </p><p class="P43"><span class="T124">For reference the GNU RNG has 3 different modes: 1) generate a double in the interval [</span><span class="T127">0</span><span class="T124">,1), generate a 32 bit integer in the interval [0, 2</span><span class="T150">31</span><span class="T124">) and generate a signed integer in the interval [-2</span><span class="T150">31</span><span class="T124">, 2</span><span class="T150">31</span><span class="T124">).</span></p><p class="P45">They all take about the same amount of time and give about the same average and standard deviation.</p><h1 class="P215"><a id="a__Other_Performance_Figures"><span/></a><a id="__RefHeading___Toc3524_643984236"/>Other Performance Figures</h1><h3 class="P236"><a id="a__Simple_Condition_File"><span/></a><a id="__RefHeading___Toc3526_643984236"/>Simple Condition File</h3><p class="Standard">The <span class="T196">next result is </span><span class="T154"> for the following condition clause:</span></p><p class="P9">condition<span class="T154">         s</span>hape(north, any 4333 + any 4432 + any 5332) <span class="T154">&amp;&amp; </span></p><p class="P9"><span class="T154">                h</span>cp(north)&gt;=20 and hcp(north)&lt;=22</p><p class="Standard">Generated 1<span class="T196">,</span>550<span class="T196">,</span>673 hands</p><p class="Standard">Produced 10<span class="T203">,</span>000 hands</p><p class="Standard">Initial random seed 113</p><p class="Standard">Time needed    2.777 sec</p><p class="Standard">real<span> 0m2.784s<span class="T196"> </span>user</span><span> <span class="T196">        </span>0m2.768s<span class="T196">        </span>sys</span><span> 0m0.022s</span></p><p class="P37">For a somewhat more complicated Stayman evaluation such as:</p><p class="P37"> </p><p class="P12">east_notrump = shape(east, any 4333 + any 4432 + any 5332) and</p><p class="P12"><span> </span><span> </span><span> hcp(east) &gt;= 15 and hcp(east) &lt;= 17</span></p><p class="P12">west_stayman = shape(west, 3451 + 4351) and hcp(west) &lt;= 7</p><p class="P12"> </p><p class="P12">east_2d = shape(east, xxxx - 4xxx - x4xx - 5xxx - x5xx)</p><p class="P12">east_2h = shape(east, x4xx)</p><p class="P12">east_2s = shape(east, 4xxx - x4xx)</p><p class="P12">east_2n = shape(east, 5xxx + x5xx)</p><p class="P12"> </p><p class="P12">d = diamonds(east)+diamonds(west)</p><p class="P12">h = hearts(east)+hearts(west)</p><p class="P12">s = spades(east)+spades(west)</p><p class="P12"> </p><p class="P12">found_d_fit = east_2d and d&gt;=8</p><p class="P12">found_h_fit = east_2h and h&gt;=8</p><p class="P12">found_s_fit = east_2s and s&gt;=8</p><p class="P12">found_M_fit = east_2n and (h&gt;=9 or s&gt;=9)</p><p class="P12"> </p><p class="P12">condition east_notrump and west_stayman</p><p class="P12"> </p><p class="P12">action</p><p class="P13"><span> average "fit" found_d_fit or found_h_fit or </span></p><p class="P13"><span class="T155">                                </span>found_s_fit or found_M_fit</p><p class="P13">fit: Mean=0.58, St<span class="T185">d</span> Dev=0.50, Var=0.25, Sample<span class="T155"> </span>Size=220 </p><p class="P23">Generated 1<span class="T196">,</span>000<span class="T196">,</span>000 hands</p><p class="P23">Produced 220 hands</p><p class="P23">Initial random seed 113</p><p class="P23">Time needed    2.249 sec</p><p class="P23">real<span> 0m2.255s<span class="T196">        </span>user</span><span> 0m2.237s<span class="T196">        </span>sys</span><span> 0m0.025s</span></p><h1 class="P216"><a id="a__Double_Dummy_Analysis_with_GIB_and_DDS"><span/></a><a id="__RefHeading___Toc3528_643984236"/>Double Dummy Analysis with GIB and DDS</h1><p class="P155"><span class="T155">Version 1.4 of Dealer (the version distributed by Debian) used GIB in double dummy mode, as a way of determining the number  of tricks that South could take in a given strain for the deal being analyzed. Compared to the other metrics used to evaluate hands, using GIB in this way is quite slow. On order of </span><span class="T156">a tenth of a second per call to GIB. (.085 secs). There are a couple of reasons for this, firstly actually solving a deal to see how many tricks can be taken is not a trivial exercise; it is much harder than just counting HCP. Secondly </span><span class="T158">each </span><span class="T156">call to GIB means creating a temporary file to hold the deal in, writing the deal to that file, starting up </span><span class="T253">the </span><span class="T156">shell program which in turn starts up the GIB program, waiting for the program to complete its analysis and write to its output file, opening and reading said file, and finally getting the number of tricks. Frankly I was surprised it was a quick as it was. However I was interested in seeing if I could improve on this for two reasons; the first of course is performance, the second it that the use of GIB in this way is a bit clumsy; not everyone may have a copy of GIB (which is no longer available on Ginsberg's web site), and GIB itself needs to be installed with certain files in certain directories. Changing directories can mean copying a couple of files from elsewhere. </span></p><p class="P156">I therefore added functionality to Dealer to give it the ability to use Bo Haglund's Double Dummy Solver (DDS). Since GIB was designed to be a bridge <span class="T157">playing </span>program  with a DD mode added on, and DDS was designed to be a double dummy solver, you might expect that DDS is more efficient, and offers more features than does GIB for this purpose. Such is indeed the case. To use DDS does not involve running any external program, you compile the DDS library right into Dealer. To solve one board, for one strain takes DDS only about one fifth the time it takes GIB. (0.0145 secs). But this is using DDS in the most <span class="T157">inefficient</span> way; DDS is optimized to obtain many results in parallel through multi-threading and re-using partial results from other calculations for the same deal. DDS can get all 20 possible result<span class="T166">s (4 declarers * 5 strains) in about the same time it would take GIB to get two results.  And this is </span><span class="T157">still</span> <span class="T165">not the best way to use DDS, but for Dealer's purposes it is more than sufficient. DDS also gives you the ability to calculate the PAR result on any given deal. </span><span class="T179"> However even for DDS the time taken is not trivial; doing a DDS calculation on thousands of deals will take some time. </span></p><p class="P157"> </p><p class="P157">In my implementation of DDS for Dealer I have borrowed a technique from  the folks who did the GIB implementation and I have 'cached' the results as they are calculated.</p><p class="P157">At this point I should digress a bit and explain that Dealer does NOT store the results of previous calculations, but recomputes them each time they are called for. </p><p class="P158">For example if in the condition clause you ask for</p><p class="P164"><span class="T189">        </span><span class="T191"> </span><span class="T60">hcp(north) &gt;= 15 and hcp(north) &lt;= 17</span><span class="T179"> </span></p><p class="P164"><span class="T179">this will result in two calls to whatever function evaluates the </span><span class="T186">HCP</span><span class="T179">. Even if you specify a variable like </span><span class="T60">NorthHCP=hcp(north)</span><span class="T179"> and then say </span><span class="T60">NorthHCP &gt;=15 and NorthHCP &lt;=17</span><span class="T179"> this </span><span class="T160">still </span><span class="T169"> results in two calls to the </span><span class="T168">HCP</span><span class="T169"> evaluation function. In fact this is </span><span class="T160">less </span><span class="T169"> efficient than the previous method since it involves first finding the variable NorthHCP in the variable list and from there calling the </span><span class="T168">HCP</span><span class="T169"> function.  </span><span class="T171">Dealer does both the find and the function call </span><span class="T161">twice</span><span class="T171">, once for each time the variable is used. </span><span class="T169">This is one reason why Dealer implements the '</span><span class="T176">analyze()</span><span class="T169">' function described earlier; analyze() pre-computes many of the commonly used metrics and stores them in a structure so that whenever they are needed it is a simple matter of table lookup. Analyze however does NOT pre-compute the GIB (or DDS) results since a) they are not often needed, and b) they would slow down EVERY deal </span><span class="T160">generated</span><span class="T169"> whether the deal satisfied the other conditions or not. The end result would make Dealer unbearably slow.</span></p><p class="P157"><span class="T166">Therefore the GIB and DDS functions save the results of previous calls in a cache so that the second time the same result is needed </span><span class="T157">on the same deal</span><span class="T166">,  it does not result in a second call to GIB (or DDS) but instead a simple array lookup.</span></p><p class="P163">End of Digression.</p><p class="P159"><span class="T167">In my implementation of DDS for Dealer, there are two ways that DDS can be called: a) the way that returns a single result and b) the way that returns all 20 possible results. Method (a) is about 5 times as fast as method (b) so obviously if you only need one to four </span><span class="T159">different</span><span class="T167"> results , such as comparing 4 of a major to 3NT, you are better o</span><span class="T170">f</span><span class="T167">f to use method (a). But if you want PAR calculations, or you are trying to build up a library of deals for future study and you want more than 4 different results per deal, you are better of</span><span class="T170">f</span><span class="T167"> to use method (b). See the </span><span class="T177">User Guide</span><span class="T167"> for details. </span></p><p class="P163">DDS also gives the user the option of specifying how many threads to run while solving the deal(s). If you are using method (a) there is no advantage to specifying more than 1 thread. If you are using method (b) you can specify between 1 and 15 threads. On my machine with 8 cores, when using method (b) I saw a gradual improvement as I increased the number of threads from 3 to 9. After that there was no additional improvement in time taken. The code therefore ships with 9 threads as the default when using method (b). The user can override this from the command line.</p><h2 class="P231"><a id="a__Experimental_Results_"><span/></a><a id="__RefHeading___Toc3530_643984236"/>Experimental Results.</h2><p class="P38"><span class="T180">The following shows the results of running Dealer with different DD solver setups, and with the DD clause before or after the other clauses in the condition statement.</span><span class="T186"> </span><span class="T211">(see the code in the next section.) </span><span class="T186">The Total Calls figures are the calls to the cached results and the calls to populate the cache. The Solve Calls figures are the number of times the actual work of solving the deal was done.</span><span class="T197"> (Mode 1 is single solution, mode 2 is 20 solutions)</span></p><p class="P38"> </p><p class="P46"> </p><p class="P46"> </p><p class="P46">../dealer Descr.DDS_slow -M2 -s17 -D2</p><p class="P46">DDS with tricks clause at start of condition -- Mode 2</p><p class="P46">Generated 395 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed  100.382 sec</p><p class="P46">Tot Calls to DDS =  7100, DDS Solve Calls=   396</p><p class="P46">Tot Calls to GIB =     0, GIB Solve Calls=     0</p><p class="P46">------------------------------------------------------</p><p class="P46">../dealer Descr.DDS_slow -M1 -s17 -D2</p><p class="P46">DDS with tricks clause at start of condition -- Mode 1</p><p class="P46">Generated 395 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed   51.637 sec</p><p class="P46">Tot Calls to DDS =  7100, DDS Solve Calls=  1980</p><p class="P46">Tot Calls to GIB =     0, GIB Solve Calls=     0</p><p class="P46">------------------------------------------------------</p><p class="P46">../dealer Descr.DDS_quick -M2 -s17 -D2</p><p class="P46">DDS with tricks clause at end of condition -- Mode 2</p><p class="P46">Generated 395 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed    6.198 sec</p><p class="P46">Tot Calls to DDS =   402, DDS Solve Calls=    22</p><p class="P46">Tot Calls to GIB =     0, GIB Solve Calls=     0</p><p class="P46">-------------------------------------------------------------</p><p class="P46">../dealer Descr.DDS_quick -M1 -s17 -D2</p><p class="P46">DDS with tricks clause at end of condition -- Mode 1</p><p class="P46">Generated 395 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed    3.030 sec</p><p class="P46">Tot Calls to DDS =   402, DDS Solve Calls=   110</p><p class="P46">Tot Calls to GIB =     0, GIB Solve Calls=     0</p><p class="P46">--------------------------------------------------------------</p><p class="P46">../dealer Descr.GIB_quick  -s17 -D2 -p20</p><p class="P46">Tricks clause at end of condition statement; 5 calls to GIB when needed</p><p class="P46">Generated 395 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed    8.109 sec</p><p class="P46">Tot Calls to DDS =     0, DDS Solve Calls=     0</p><p class="P46">Tot Calls to GIB =   402, GIB Solve Calls=   110</p><p class="P48">--------------------------------------------------------------</p><p class="P46">../dealer Descr.GIB_slower  -s17 -D2 -p20</p><p class="P46">Tricks clause at Start of condition statement; 5 calls to GIB on each hand</p><p class="P46">Generated 395 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed  152.405 sec</p><p class="P46">Tot Calls to DDS =     0, DDS Solve Calls=     0</p><p class="P46">Tot Calls to GIB =  7100, GIB Solve Calls=  1980</p><p class="P46">-----------------------------------------------------------------------------</p><p class="P49"> </p><p class="P49"> </p><p class="P49">../dealer Descr.DDS1x_slow -M1 -s17 -D2</p><p class="P46">DDS with tricks clause at START of condition only 1 call per hand</p><p class="P46">Generated 362 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed    8.016 sec</p><p class="P46">Tot Calls to DDS =   363, DDS Solve Calls=   363</p><p class="P46">Tot Calls to GIB =     0, GIB Solve Calls=     0</p><p class="P46">------------------------------------------------------------------------------</p><p class="P46"> ../dealer Descr.GIB1x_slower  -s17 -D2 -p20</p><p class="P46">GIB with tricks clause at START of condition only 1 call per hand</p><p class="P46">Generated 362 hands</p><p class="P46">Produced 20 hands</p><p class="P46">Initial random seed 17</p><p class="P50">Time needed   30.054 sec</p><p class="P46">Tot Calls to DDS =     0, DDS Solve Calls=     0</p><p class="P46">Tot Calls to GIB =   363, GIB Solve Calls=   363</p><p class="P46">================================================================</p><h2 class="Heading_20_2"><a id="a__The_condition_statement_used_in_the_5x_tests"><span/></a><a id="__RefHeading___Toc29076_2914024446"/>The condition statement used in the 5x tests</h2><p class="P47"># These next statements calculate the maximum number of tricks North can take in any strain.</p><p class="P47"># The five calls per deal that populate the cache</p><p class="P47">nNtrix = tricks(north, notrumps) </p><p class="P47">nStrix = tricks(north, spades)</p><p class="P47">nHtrix = tricks(north, hearts)</p><p class="P47">nDtrix = tricks(north, diamonds)</p><p class="P47">nCtrix = tricks(north, clubs)</p><p class="P47"># the IF statements that generate the extra calls to the DD solver.</p><p class="P47">ntrixM = nStrix &gt; nHtrix ? nStrix : nHtrix</p><p class="P47">ntrixm = nDtrix &gt; nCtrix ? nDtrix : nCtrix</p><p class="P47">ntrixT = ntrixM &gt; ntrixm ? ntrixM : ntrixm</p><p class="P47">ntrix  = ntrixT &gt; nNtrix ? ntrixT : nNtrix</p><p class="P67"><span class="T181">condition  </span><span class="T183">  </span><span class="T184">( </span><span class="T215">ntrix &gt; 6</span><span class="T184">  ) &amp;&amp;                </span><span class="T183">/* </span><span class="T214">ntrix &gt; 6</span><span class="T183"> clause goes here for the slow runs */</span></p><p class="P67"><span class="T183">      </span><span class="T182">s</span><span class="T181">hape(north, any 4333 + any 4432 + any 5332) and</span></p><p class="P47"><span class="T216">      </span>hcp(north)&gt;=15 and hcp(north)&lt;=18 and hcp(south) &lt;= 12 <span class="T216">   /* </span>&amp;&amp; <span class="T212">(ntrix &gt; 6)</span><span class="T213"> </span><span class="T217">goes here for quick runs*/</span></p><p class="P47"># The <span class="T212">ntrix&gt;6 </span>clause is <span class="T195">at</span> the beginning of the condition statement for the 'slow' runs, and <span class="T195">at</span> the end for the 'quick' runs.</p><p class="P51">=======================================================================================</p><p class="P51"> </p><p class="P61">Conclusion:</p><p class="P60">1. Avoid calling a double dummy solver on EACH hand, whether DDS or GIB</p><p class="P60">2. Caching makes a big difference especially when there are many calls using the same value of tricks.</p><p class="P60">3. DDS mode 1 is 3-4 times faster than GIB for 'ordinary' use. i.e. 1-5 double dummy calls per hand.</p><p class="P60">4. DDS mode 2 is quicker than GIB by about 30% when there are 5 calls to GIB per hand.  When there are only one or two calls it is slower.</p><p class="P60">5. GIB consistently takes about 0.08 seconds per call. DDS mode 1 about 0.0017 seconds</p><h2 class="P232"><a id="a__Performance_of_the_DealerServer"><span/></a><a id="__RefHeading___Toc3465_3437249550"/>Performance of the DealerServer</h2><p class="P173">The usereval keyword also calls an external program; however this external program is only started once, not like GIB or OPC, and it uses very efficient shared memory between Dealer and DealerServer to communicate. Further it can return up to 64 numbers on each call, which are then cached. The overall effect is that it is the quickest of the set, {DDS, GIB, OPC, or DealerServer}.</p><p class="P173"> </p><p class="P104">A very simple UserEval function, which just returns a fixed set of numbers every time it is called,</p><p class="P103">will take <span class="T11">178.7</span> secs, for 10 thousand calls, or about <span class="T11">0.018 </span>secs per call.</p><h1 class="P217"><a id="a__Performance_Summary_of_Various_External_Programs"><span/></a><a id="__RefHeading___Toc3309_3276467367"/>Performance<span class="T254">  Summary</span><span class="T261"> of Various External Programs</span></h1><p class="P94">Performance Summary:<span> Secs</span></p><p class="P94">DDS Mode 1. Per Call:<span> 0.027</span></p><p class="P94">DDS Mode 2. Per Call:<span> 0.26</span></p><p class="P94">GIB                 Per Call:<span> 0.08</span><span> </span></p><p class="P94">OPC                Per Call:<span> 0.037</span></p><p class="P94">UserEval         Per Call:<span> 0.018</span><span> </span></p><p class="Standard"> </p><h1 class="P218"><a id="a__The_Shape_Functions_--_H__van_Staveren___F__Dellacherie"><span/></a><a id="__RefHeading___Toc10468_3480997658"/>The Shape Functions -- H. van Staveren &amp; F. Dellach<span class="T244">e</span>rie</h1><h2 class="P233"><a id="a__HvS_shape______"><span/></a><a id="__RefHeading___Toc10470_3480997658"/>HvS<span class="T242"> sha</span>pe( .. )</h2><p class="Standard">The original shape function by HvS is called from the Input File with the keyword 'shape' and the arguments in parentheses<span class="T212"> ()</span>. The arguments are 4 character strings made up of the digits 0-9 and the letter 'x'.  The arguments are called distributions. Several distributions can be joined together with a plus sign (+) meaning 'or'.  The suits are given in the usual order of S, H, D, C. For example the distribution 5431 means 5 spades, 4 hearts, 3 diamonds, and 1 club, or as it is usually written in bridge columns 5=4=3=1. A distribution such as 54xx means 5=4 in the Majors and the 4 minor suit cards can be distributed in any way from 4=0 to 0=4. </p><p class="Standard">Each <span class="T230">distribution can be preceded by the keyword 'any', to indicate that the order of the suits does not matter. For example 4333 means a distribution with 4 spades; </span><span class="T237">'</span><span class="T230">any 4333</span><span class="T237">'</span><span class="T230"> means the 4 cards can be in any suit. A distribution  such as 'any 54xx' would include 54xx, 5x4x, 5xx4, 45xx, 4x5x, 4xx5, and so on. </span></p><p class="P80">After all the included distributions have been listed, the user can exclude certain distributions by prefixing them with a minus (-) sign. So that 5332 + any 6xxx -  4xxx would exclude hands with exactly 4 spades. The list of distributions can be almost arbitrarily long. I have tested cases with 175 distributions in the list. </p><p class="P80"> </p><p class="P81">The shape() functionality itself is made up of three phases:  the<span class="T231"> intialization phase, </span>the parsing phase,<span class="T232"> </span><span class="T231">and the evaluation phase.</span></p><h3 class="P237"><a id="a__shape___Initialization_Phase"><span/></a><a id="__RefHeading___Toc10472_3480997658"/>shape() Initialization Phase</h3><p class="P84"><span class="T237">To store the distribution information about a hand, there is a 4D array called, </span><span class="T194">distrbitmaps</span><span class="T129">   This array has one cell for each possible length in a suit. Since there are 14 possible lengths for any suit (0 .. 13) a naive way of allocating this array would be distribitmaps[14][14][14][14]. This would result in an array of </span><span class="T128">38,416 cells requiring 153,664 bytes of storage. So that to get the information about a hand with 5=4=3=1 shape, we would  say </span><span class="T77">shapebits = distribitmaps[1][2][4][5]</span><span class="T128">, where the first index is the number of clubs, and the last one is the number of spades. But a bit reflection will show that many of these cells will never contain any data. For example the sub-array </span><span class="T9">distribitmaps[13][x][x][x]</span><span class="T128"> in the above scheme will consist of 2744 cells, only one of which will be used: </span><span class="T9">distribitmaps[13][0][0][0].</span><span class="T128"> Similarily if we have 12 clubs, only 3 of the 2744 cells in the distribitmaps[12]  sub array can be used: distribitmaps[12][1][0][0], distribitmaps[12][0][1][0], distribitmaps[12][0][0][1]. The same is true for all of the other distributions; many of the cells will never be used. Hans therefore instead of this naive approach has generated </span><span class="T130">679 separate sub arrays, with a total size of only 14,840 bytes (plus a bit of </span><span class="T130">overhead). A saving of over 90%. The programmer however can still refer to the distribitmaps array just like a real 4D array by issuing a C statement such as:</span></p><p class="P17">shapebits= distribitmaps[club_len][diam_len][heart_len][spade_len].</p><p class="P91">This array is created at run time before the parser is called so that it is available to the parsing routines to store information about shape requirements in.</p><h3 class="P238"><a id="a__shape___Parsing_Phase"><span/></a><a id="__RefHeading___Toc10474_3480997658"/>shape() Parsing Phase</h3><p class="P82">During the parsing phase two things occur: First when the parser sees the shape( ....) statement it creates a new node in the decision tree (or a new expression tree in the var list). This node carries with it two pieces of information: the compass direction for which the shape constraint applies, and an integer referred to in the program as '<span class="T56">shapeno</span>'. The shape number referred to is a number identifying the shape statement as a whole, NOT any individual distribution in the statement. The 'shapeno' is used to create a bit mask that can test for the relevant shapes.</p><p class="P85"><span class="T231">A compass direction can have several shape statements that refer to it; there is no requirement that a compass direction appear </span><span class="T242">in </span><span class="T231">only on</span><span class="T238">e</span><span class="T231"> shape statement.  For example:</span></p><p class="P16">condition shape(north, xxx6 + xx6x ) &amp;&amp; hcp(north) &gt;=11 or shape(north, 5xxx + x5xx ) &amp;&amp; hcp(north)&gt;=11</p><p class="P82">so that to open an 11 count in a minor needs a 6 card suit, is perfectly OK. Each of the shape statements in the above will create its own node in the decision tree, and will have its own <span class="T56">shapeno.</span></p><p class="P82">The second thing that happens<span class="T232"> is that each distribution in the shape statement is evaluated and the 4D array created in the intialization phase is updated. The integer</span><span class="T237"> from </span><span class="T232">distribitmap[c][d][h][s] is retrieved and the bit corresponding to the current shapeno is set. (or cleared if the distribution is preceded by a minus sign). There may be other bits in the same integer that have been set, and these are not disturbed by the new information. Thus each integer in the 4D array can carry information about 32 different shape statements. Since each shape statement can specify an almost unlimited number of distributions this gives the user the ability to control the overall shape as much as he wants. </span></p><p class="P86">The hard part is figuring out which lengths to use to set the bits in the 4D array. A distribution such as 5431 is straightforward, there is only one cell in the 4D array that is affected. It is a bit more difficult if the user specifies 'any 5431'. Now there are 24 cells in the 4D array that need to have the relevant shapeno bit set. It gets even harder if there are 'x's in the distribution;  a distribution such as 'any 7xxx' can occur in 196 different ways.  However it happens there is a routine called 'setshapebit' that will set bit number 'shapeno' in the 4D array for each distribution that qualifies. 'shapeno' is essentially incremented by one for each shape(compass, xxxx + xxxx + .... ) statement. So the first call to shape will set shapno to zero, and the least significant bit in the affected cells in the 4D array will be set to 1 giving them a value of '1'. The third shape(compass, ... ) statement will set shapeno to 2 and the affected cells will have their '2' bit set, in effect incrementing them by '4'. (2**2).</p><p class="P87">A given distribution may occur in two different shape statements. For example it is possible to ask that either (or both) of north and west have 5=4=3=1 shape. In that case two bits will be set in the distribitmaps[1][3][4][5] cell giving it a value of say 3. </p><h3 class="Heading_20_3"><a id="a__Evaluating_shape__"><span/></a><a id="__RefHeading___Toc10476_3480997658"/><span class="T239">Evaluating shape()</span> </h3><p class="P86">To test if the compass direction meets the shape condition, the cell corresponding to that compass' distribution is retrieved and the relevant bit is tested by anding it with '1' shifted by <span class="T239">'</span>shapeno<span class="T239">'</span>. For example suppose that the North hand is 6=4=2=1 and the North shapeno is 2. Suppose further that the shape condition for West is  any 6421 and that for North is any 5332. Then to check if North (with 6=4=2=1) meets the condition, we use a statement such as the following:</p><p class="P18">if ( distribitmaps[1][2][4][6] &amp; (1&lt;&lt;2)<span class="T239"> </span>){ then true } else {false}. </p><p class="P18"><span class="T109">Now the integer in the [1][2][4][6] will be non zero because of the West condition; but it will not have it's '2' bit set, because only cells that match North's 5332 requirement will have that bit set, and this is not one of them. When we test West  (perhaps with a 1=4=2=6 distribution) with a statement like that above  we will use a different value from '2' to shift the '1' and we will get a match in that case.</span> </p><h2 class="P234"><a id="a__François_Dellacherie_Shape{____}"><span/></a><a id="__RefHeading___Toc10478_3480997658"/><span class="T242">François Dellach</span><span class="T244">e</span><span class="T242">rie </span>Shape<span class="T240">{</span> .. <span class="T240">}</span></h2><p class="P90"><span class="T240">The second kind of shape statement that Dealer Version 2.</span><span class="T247">x</span><span class="T240"> allows is one where the arguments are enclosed in </span><span class="T18">braces {}</span><span class="T240">, not parentheses (). The braces versus parentheses is how we tell them apart.  I call them FDshapes and FDdistributions because the code to implement them was written, back in 1997, by François Dellach</span><span class="T244">e</span><span class="T240">rie. The complete syntax for specifying an FDdistribution is given in the User Guide. In brief it allows the user to specify in a very compact form shape contraints that would take dozens or in some cases over a hundred different </span><span class="T241">H</span><span class="T240">vS distributions. For example this FDdistribution: </span><span class="T78">shape{east, 4+m5-Mxx }</span><span class="T240"> </span><span class="T241">spec</span><span class="T243">ifie</span><span class="T241">s</span><span class="T240"> at least a 4 card minor, at most a 5 card Major</span><span class="T241">.</span><span class="T243"> It</span><span class="T240"> expands to 990 characters, and 142 distributions from 0409 to x5x7 </span></p><p class="P88">See the Examples directory for more examples on how to use an FDshape statement. </p><p class="P88">The expansion of this compact distribution clause is done by an external Perl script. The Perl script is called <span class="T56">fdp </span><span class="T90">and it resides in the lib directory. There is also a version called </span><span class="T56">fdp</span><span class="T79">i </span><span class="T110">which is an interactive version. The interactive version allows the user to enter an FDshape command from the keyboard, and see the results on his screen. It is a good way to test an FDshape statement that you intend to include into the Dealer Input file.</span></p><p class="P27">When the lexer, Flex, sees a <span class="T11">shape{ .. }</span> statement, it does not return said statement immediately to the parser. Instead it passes the statement to the ../lib/fdp Perl script via a Linux <span class="T56">popen</span> system call.  The script (if it is working correctly) creates a valid HvS shape command from the FDshape command. Flex captures the results produced by the script, and then switches from lexing the Input File to lexing the script results, passing each term produced by the script to the parser just as if the user had entered them by hand. The parser never sees the shape{ .. } text, but only the text transformed by the FD Perl script.</p><p class="P89"><span class="T110">F</span><span class="T90">rom that point on the shape requirement is handled exactly the same way as described above.</span></p><h1 class="P219"><a id="a__Installing_Dealer_V2_From_the_Github_Repo_"><span/></a><a id="__RefHeading___Toc29078_2914024446"/>Installing Dealer V2 From the Github Repo.</h1><h2 class="Heading_20_2"><a id="a__Warning_"><span/></a><a id="__RefHeading___Toc29080_2914024446"/>Warning:</h2><p class="Standard">I am NOT an experienced package maintainer. This is the first time I have ever used Github.</p><p class="P71">There is no package (.deb or .rpm) that will automatically install Dealer for you.<span class="T218"> </span></p><p class="P72"> </p><p class="P73">I assume that one of these three things is true:</p><p class="P69">1) The binary in the Prod directory will run as is on a Linux system. This may or may not be true. While DealerV2 itself does not rely on any DLL's there are several references to standard GCC and Linux DLL's in the code. The binary was developed on Linux Mint<span class="T227">,</span> an Ubuntu derivative. If some other distro puts it's .so libraries in a different location this assumption may not be valid.</p><p class="P69"> </p><p class="P71"><span class="T218">2</span><span class="T221">a) </span><span class="T218">Cloning the git hub repo and then building from source with a </span><span class="T62">make</span><span class="T218"> command will work.</span></p><p class="P73"><span class="T221">2b) </span>Github also gives you the option of downloading a ZIP file of the code. I did not create this zip file it is done automatically by Github.  <span class="T221">I assume that if you download the ZIP and unpack it this will be the equivalent of cloning it. </span></p><p class="P73"> </p><p class="P73">3) You are an experienced developer that knows how to build stuff on your system.</p><p class="P73">If you are going to try to get this program to work on Windows that is your best option. As stated in the User Guide, Windows Subsystem For Linux can run this binary. But maybe not<span class="T248"> on your system</span>. Maybe you have to rebuild for <span class="T248">your </span>WSL. If that is the case you are more or less on your own. I have no experience developing for Windows. </p><p class="P73"> </p><h2 class="P235"><a id="a__Installation_From_the_Github_Repository"><span/></a><a id="__RefHeading___Toc29082_2914024446"/>Installation From the Github Repository</h2><p class="P70">Obviously you will need to have already installed <span class="T56">git </span>if you are going to do this. </p><p class="P70">First cd to the directory where you want the repo to reside e.g. <span class="T56">cd ~/BridgeStuff</span></p><p class="P70">Second clone the github repo with the command:</p><p class="P14">git clone<span class="T220"> </span>https://github.com/dealerv2/Dealer-Version-2-</p><p class="P70"><span class="T157">Note the trailing </span><span class="T162">dash</span>.</p><p class="P70">You should wind up with a new directory under BridgeStuff  called: <span class="T56">Dealer-Version-2-</span></p><p class="P24">If you then type the command: <span class="T56">tree -L 1</span> <span class="T56">Dealer-Version-2-</span><span class="T64">  </span>(note the space after the L) </p><p class="P68"> </p><p class="P68">The result will be:</p><p class="P68">.</p><p class="P68">├── DDS_Demo</p><p class="P68">├── dealerv2 -&gt; Prod/dealerv2</p><p class="P68">├── Debug</p><p class="P68">├── DebugExamples</p><p class="P68">├── docs</p><p class="P68">├── DOP</p><p class="P68">├── DOP4DealerV2.tar.gz</p><p class="P68">├── Examples</p><p class="P68">├── include</p><p class="P68">├── install_dealer.bash</p><p class="P68">├── lib</p><p class="P68">├── LICENSE_GPLV3</p><p class="P68">├── Prod</p><p class="P68">├── README.md</p><p class="P68">├── src</p><p class="P68">├── stdlib</p><p class="P68">└── Un_install_dealer.bash</p><p class="P68">└── src/</p><p class="P68">The primary directories of interest are the Prod/ directory and the Examples/ directory.</p><p class="P68">The binary for Dealer is<span class="T11"> dealerv2</span><span class="T15"> </span><span class="T220">in the </span><span class="T15">Prod </span><span class="T220">directory. </span> There are many examples of Dealer input files with names beginning with "Descr." in the Examples directory.</p><p class="P68">To <span class="T219">(re)-build the binary cd to the Prod directory and type </span><span class="T63">make</span><span class="T219">. Ignore the warnings about unused variables and the tmpname function and so forth.</span></p><p class="P68"> </p><p class="P74">If you have downloaded the zip file the process is similar. After un-zipping the zip file, you should be able to run the <span class="T56">tree -L </span>and <span class="T56">make</span> commands as above.</p><p class="P73"> </p><h2 class="P235"><a id="a__After_Getting_The_Repository"><span/></a><a id="__RefHeading___Toc29084_2914024446"/>After Getting The Repository</h2><p class="P73">There are README files in some of the various directories that explain what each one does.</p><p class="P73">For someone that just wants to use the program, the most important directories are the Prod directory (where the <span class="T43">dealerv2</span> binary is; copy it to wherever you like and run it from there) and the Examples directory where there are several files beginning with "Descr.?????" These are examples of instructions to Dealer to generate various sorts of hands. The other files in this directory are typically outputs from the various Descr.???? files.</p><p class="P92">Most of the files in the repository are write protected; even for their owner. This is to prevent accidents. </p><p class="P92"> </p><p class="P92">The owner can always give himself write priviledges with: <span class="T56">chmod -R u+w * </span>if he wants to modify or delete anything. </p><p class="P73"> </p><p class="P93"><span class="T245">In order to use OPC hand evaluation or François Dellacherie shapes, you need to install Dealer with  s</span><span class="T80">udo install_dealer.bash</span><span class="T245"> and it will copy the repository structure to /</span><span class="T80">usr/local/bin/DealerV2</span><span class="T245"> and </span><span class="T80">/usr/local/bin/DOP</span><span class="T245">. It will also update your PATH setting in .bashrc. This step is necessary because the paths to the DOP and fdp Perl scripts are hard coded into the program. </span></p><h3 class="P239"><a id="a__FDP"><span/></a><a id="__RefHeading___Toc3120_2383521750"/>FDP </h3><p class="P168">fdp is a perl script consisting of two files. Both of these files are in the lib subdirectory of the DealerV2 distribution. <span class="T245">The path to these files is hard coded into the Dealer source as: </span><span class="T80">/usr/local/bin/DealerV2/lib/fdp</span></p><h3 class="Heading_20_3"><a id="a__GIB"><span/></a><a id="__RefHeading___Toc29086_2914024446"/>GIB</h3><p class="P74">As explained in the user guide if you want to use the <span class="T11">tricks</span> function of Dealer you will need to install GIB. How to obtain and install GIB is not something covered here. Furthermore there is really no reason to use GIB once you have Version 2 working. The <span class="T11">dds</span> function does what the <span class="T11">tricks </span>function does and does it 5x faster. In the intrests of completeness however I will repeat here what is in the User Guide: the name of the GIB program is has been changed for Version 2 from version <span class="T228">O</span>ne. In version <span class="T228">O</span>ne, the program name was '<span class="T43">bridge</span>'. Linux already has a utility called 'bridge' and it refers to configuring LAN cards. So when the user asks for the <span class="T11">tricks</span> function, Dealer version 2 tries to run the binary <span class="T56">/usr/games/gibcli. </span><span class="T90">If you do install GIB make sure you either rename it or create a symlink to it accordingly.</span></p><h3 class="Heading_20_3"><a id="a__DOP"><span/></a><a id="__RefHeading___Toc29088_2914024446"/>DOP</h3><p class="P75"><span class="T90">There is one external program that you might want to install however and that is the DOP program that implements the </span><span class="T106">opc</span><span class="T90"> function. This is a Perl program. It is in the file: </span><span class="T65">DOP4DealerV2.tar.gz</span></p><p class="P25">To install this you need to create the directory <span class="T56">/usr/local/bin/DOP</span>. To do this you must have super user priviledges. Then you unpack the tarball in that directory. if you type </p><p class="P25"><span class="T56">tree -L 1</span> <span class="T56">/usr/local/bin/DOP</span> you should see:</p><p class="P26">/usr/local/bin/DOP</p><p class="P26">├── Copyright_Notice.txt</p><p class="P26">├── Doc</p><p class="P26">├── DOP -&gt; dop</p><p class="P26">├── dop</p><p class="P26">├── DOP_Calculation_Subs_V21.pl</p><p class="P26">├── DOP_Competition_Subs_V21.pl</p><p class="P26">├── DOP_main_V21.pl</p><p class="P26">├── DOP_Requires_V21.pl</p><p class="P26">├── DOP_Subs2_V20.pl</p><p class="P26">├── DOP_Subs2_V21.pl</p><p class="P26">├── DOP_Subs_V21.pl</p><p class="P26">├── DOP_Util_Subs_V21.pl</p><p class="P26">├── DOP_Var_Defns_V21.pl</p><p class="P26">├── Examples</p><p class="P26">├── GPL_V3.pdf</p><p class="P26">└── subxref.txt</p><p class="P76">If you want to test that this has worked correctly you can say:</p><p class="P76">/<span class="T56">usr/local/bin/DOP/dop &lt;/usr/local/bin/DOP/Doc/1deal.dat</span></p><p class="P76">and you will get a bunch of output that starts out looking like this:</p><p class="P10">{******* DOP Deal Detail  Report Deal: 391 ****** QK_Losers}</p><p class="P10"> Deal# O  HLF_NT NT-D NT-Tx %  LS HLDFl LS-Tx %  [S,NT] \</p><p class="P10">                                      &lt;------------------- Hand ------------------&gt;</p><p class="P10">[0391] W  34.50  0, 0 12  55    D 36.50  13  71   0,0   \</p><p class="P10">                                      [Ax/xxx/Kxxxx/AKx :: xx/AKQx/AQxx/Qxx       ]</p><p class="P10">[0391] HL[32.50] ADJ[-1] HF[1] FN[2] Misfit[ 0] Mirror[-1] Waste[0.0] noWASTE[  0]</p><p class="P10">   DFit_in: Sp[0], He[0], Di[2], Cl[0]  FNs=&gt; S[ 0] H[ 0] D[ 2] C[ 0]</p><p class="P10">    Descr:      6 NT on x pts  </p><h3 class="P240"><a id="a__The_Repository_Contents"><span/></a><a id="__RefHeading___Toc29090_2914024446"/>The Repository Contents</h3><p class="P77"><span class="T222">As stated earlier the two directories Prod/ and Examples/ are the ones that are of primary interest to the ordinary user. <br/></span><span class="T163">Prod/</span><span class="T222"> contains the </span><span class="T71">dealerv2</span><span class="T222"> binary and the </span><span class="T71">Mak</span><span class="T72">e</span><span class="T71">file </span><span class="T222">that is used to build this binary.</span></p><p class="P76"><span class="T157">Examples/ </span>contains samp<span class="T223">le</span> Dealer Input Files and the results of running some of these files. <br/>It also contains some utilities to check that Dealer is operating correctly. These are of real interest only to those who are rebuilding Dealer from source.</p><p class="P76"><span class="T157">DDS_Demo/ </span>This directory is not related to Dealer directly. It is mainly of interest to developers who want an example of how to use the DDS libraries. See the README file in the directory.</p><p class="P78"><span class="T164">Debug/</span><span class="T172"> This directory is where to build debug versions of Dealer. The main</span><span class="T173"> </span><span class="T172">difference is in the Makefile. </span><span class="T173">One of the very first lines defines the symbol JGMDBG which causes the conditional compilation of Debugging statements to be turned on. The other difference is that the compilation is done with the gcc flag -Og (which is approximately equal to -O1 but with some debugging symbols left in) instead of -O3 which optimizes the binary for speed.  </span><span class="T174">The output file is called </span><span class="T69">dealdbg</span><span class="T174"> and if you </span><span class="T175">run</span><span class="T174"> it with ./</span><span class="T67">dealdbg -D2 -Xjunkfile -0 "x5xx + 5xxx - 1xxx -0xxx" -V</span><span class="T174"> </span></p><p class="P79"> </p><p class="P79">You should get as output:</p><p class="P11">Version info....</p><p class="P11">Revision: 102.5.0 </p><p class="P11">Build Date:[2022/11/15] </p><p class="P11">$Authors: Hans, Henk, JGM $</p><p class="P11">JGMDBG is defined. Debugging printing to stderr is active</p><p class="P11">JGMDBG DEFINED= 1 in main </p><p class="P11">--------HELLO FROM VERSION 102.5.0 ---------- </p><p class="P11">YYDEBUG NOT Defined.  BISON DBG IN_Active.  </p><p class="P11">Showing Options with Verbosity = 1</p><p class="P11"><span>  g:Maxgenerate=[100000]</span></p><p class="P11"><span>  m:ProgressMeter=[0]</span></p><p class="P11"><span>  p:Maxproduce=[40]</span></p><p class="P11"><span>  q:Quiet=[0]</span></p><p class="P11"><span>  s:Seed=[0]</span></p><p class="P11"><span>  u:UpperCase=[1]</span></p><p class="P11"><span>  v:Verbose=[1 ; 1]</span></p><p class="P11"><span>  x:eXchange aka Swapping=[0]</span></p><p class="P11"><span>  C:Fname=[] mode=[]</span></p><p class="P11"><span>  D:Debug Verbosity=[2] set to 2</span></p><p class="P11"><span>  M:DDS Mode=[1] set to 1</span></p><p class="P11"><span>  O:Opener=[N, 1]</span></p><p class="P11"><span>  P:Par Vuln=[-1]</span></p><p class="P11"><span>  R:MaxThreads=[1]</span></p><p class="P11"><span>  R:MaxRamMB=[160]</span></p><p class="P11"><span>  T:Title=[],len=0</span></p><p class="P11"><span>  N:PreDeal=[]</span></p><p class="P11"><span>  S:PreDeal=[]</span></p><p class="P11"><span>  E:PreDeal=[]</span></p><p class="P11"><span>  W:PreDeal=[]</span></p><p class="P11"><span>  X:Fname=[junkfile]</span></p><p class="P11"><span>  U:Fname=[]</span></p><p class="P11">Showing Script Vars with Verbosity = 1</p><p class="P11"><span>  [$0]=x5xx + 5xxx - 1xxx -0xxx</span></p><p class="P79"> </p><p class="P53">DebugExamples/<span class="T174"> This directory contains many Dealer Input Files that were used at one time to test various features of Dealer. They might prove useful or not. Browse at leisure.</span></p><p class="P53">docs/<span class="T174"> </span><span class="T175"> This directory contains the License file, the Copyright Notice, the User Guide and other explanatory documentation.</span></p><p class="P53">include/<span class="T175"> The directory with the C header files that are included in most of the source files. There is also the dummy headerfile, "</span><span class="T68">allheaders.h</span><span class="T175">". If you update the timestamp on this file, usually with a </span><span class="T68">make allheaders</span><span class="T175"> command, it will cause Dealer to be rebuilt from scratch.</span></p><p class="P53">lib/<span class="T175"> The directory with some supporting files. The most important one being </span><span class="T70">libdds.a</span><span class="T175"> the DDS library. it also includes the tarball for the DOP code written in Perl.</span></p><p class="P53">src/<span class="T175"> The directory that includes all of the .C source files for the program.  It also includes the grammar file used by Bison/Yacc, </span><span class="T68">dealyacc.y </span><span class="T175">and the lexer file used by Flex, </span><span class="T68">dealflex.l</span></p><p class="P15"> </p><p class="P28"><span class="T175">B</span><span class="T166">ecause the paths to the DOP/OPC, and François shape scripts are hard coded into the Dealer source it is best if the installer run</span><span class="T178">s</span><span class="T166">: </span><span class="T66">sudo install_dealer.bash</span><span class="T166"> from the repository directory. This will copy all of the repo files to </span><span class="T66">/usr/local/bin/DealerV2</span><span class="T166"> and </span><span class="T66">/usr/local/bin/DOP </span><span class="T166">and then Dealer can be run from any location without problems. </span></p><p class="P28"><span class="T166">All of the files in the repository have been write  protected to prevent accidents. But the user can easily reverse this with </span><span class="T66">chmod -R u+w *</span></p><h1 class="P226"><a id="a__Appendix_-_Adding_the_CSV_Report"><span/></a><a id="__RefHeading___Toc29314_670075485"/>Appendix - Adding the CSV Report</h1><p class="P62">The most extensive piece of functionality I added to Dealer was the CSV report. The DDS functionality had more C code, but did not touch quite as many pieces of Dealer as the CSV report functionality. The following can be used as a kind of checklist if you want to add functionality of your own. <span class="T206"> Not every step that I took here will be needed.</span></p><p class="P62"> </p><p class="P62">1.  Define the grammar in dealyacc.y</p><p class="P178">1.1 a new %token <span class="T204">for: </span>CSVRPT<span class="T204">, DEAL, SIDE, and TRIX. </span></p><p class="P178">1.2 a new type in the union structure, a pointer to a <span class="T61">struct. struct csvterm_st *y_csv</span></p><p class="P178">1.3 a new %type for csvlist, <span class="T61">%type &lt;y_csv&gt; csvlist</span></p><p class="P179">1.4 new rules for csvlist, allowing for expressions, strings, and collections of bridge hands<span class="T204">, and trick taking.</span></p><p class="P179">1.5 new rules for the csvrpt action, giving the code to build the new<span class="T204"> action node of type CSVRPT and add it to </span>the list of actions. </p><p class="P180">1.6 new rules for the various terms in the csvlist,  to add a node to the list of expressions that are to by printed to the csv report. Populate the node with the type and semantic value. </p><p class="P179"> </p><p class="P186">2. Define the token patterns in dealflex.l</p><p class="P180">2.1 when the pattern csvrpt is seen return the value of CSVRPT</p><p class="P180">2.1 when the patterns for the csvlist bridge hands are seen set <span class="T56">yylval</span> accordingly and return the related tokens. (DEAL, TRIX, SIDE, STRING, etc. )</p><p class="P187"> </p><p class="P187"> </p><p class="P187">3. <span class="T205">Header Files in include directory</span></p><p class="P181"><span class="T205">3.1 </span>Define a new type in <span class="T56">dealdefs.h</span>: a struct that implements the various types of terms in the csvlist</p><p class="P182">3.2 Define new variables to hold the output buffer of the report, and an array to hold the results of the trix calculation. Modify <span class="T56">dealglobals.c </span>and <span class="T56">dealexterns.h</span> accordingly.</p><p class="P182">3.3 Modify the <span class="T56">dealtypes.h </span>file to reflect the new command line options structure. </p><p class="P182">3.4 Modify the <span class="T56">dealprotos.h</span> file to provide an external link to the new functions in <span class="T56">dealdds_subs.c</span><span class="T81"> </span>and <span class="T56">dealaction_subs.c</span></p><p class="P191">4. Action Subs Code</p><p class="P194"><span class="T229">4.1 </span><span class="T205">Modify the </span><span class="T75">dealaction_subs.c</span><span class="T205"> file to contain the code to run when a</span><span class="T249">n action of type</span><span class="T205"> CSVRPT is found. Essentially modify the case statement in the </span><span class="T16">action() </span><span class="T205">function. Also add to the case statements in the </span><span class="T16">setup_action() </span><span class="T205">and </span><span class="T16">cleanup_action</span><span class="T17">()</span><span class="T205"> functions.</span></p><p class="P189"> <span class="T229">4.2 </span>Add code to the <span class="T56">dealaction_subs.c</span> file to format the deal for printout; </p><p class="P189"><span class="T229">5</span><span class="T206">. A</span>dd code <span class="T206">to </span><span class="T76">dealdds_subs.c</span><span class="T206"> </span>to call the double dummy solver routines, and to change the mode of the double dummy solver, if required.</p><p class="P188"><span class="T229">6</span>. Add code to the <span class="T56">mainsubs.c </span>file, and the <span class="T56">dealerv2.c</span> file to process the new command line switch that gives the filename and write mode of the CSV report file. </p><p class="P190"><span class="T229">7</span>. Write new page in users guide.</p><p class="P190"><span class="T229">8</span>. Conduct regression tests to ensure I did not break anything. </p><p class="P192">9. Since csvrpt did not require any new evaluation or decision making, no mods t<span class="T233">o </span><span class="T56">dealeval_subs.c</span> were needed.</p><p class="P190"> </p><p class="P193"><a href="#a_Top" class="Internet_20_link">Top</a></p><p class="P193"> </p><h1 class="P221"><a id="a__The_DealerServer_Infrastructure"><span/></a><a id="__RefHeading___Toc3467_3437249550"/>The DealerServer Infrastructure</h1><p class="P105">The DealerServer functionality is implemented via three components. </p><p class="P107"><span class="T263">1. </span><span class="T262">The first component</span><span class="T264"> </span><span class="T262">is the code added to the Dealer program itself. This code is also made up of three components:</span></p><p class="P183">1.1 <span class="T262">mods to the grammar to parse and process the usereval keyword</span></p><p class="P183">1.2 <span class="T262">mods to the setup portion of Dealer to create the DealerServer shared memory, the semaphores, and to start the execution of the DealerServer daemon.</span></p><p class="P183">1.3 <span class="T262">mods to the evaluation functions in dealeval_subs.c to make use of the numbers returned by the DealerServer daemon.</span></p><p class="P183"> </p><p class="P196">2. The second <span class="T262">component</span> is the DealerServer infrastructure code. This code maps to the shared memory location created in section 1.2 above, and also sets up communication channels via the semaphores. <span class="T268">It also looks after keeping the cache up to date. There are in effect two caches, one for each side. The cache is refreshed each time the deal changes, and also if the user asks for a different query  aka metric to run. </span>Having this basic code pre-written means the user need only code the third piece.</p><p class="P195"> </p><p class="P196">3. The third <span class="T262">component</span> is the code that implements whatever custom evaluation method the user needs to return meaningful numbers to Dealer. This user custom code is linked with the DealerServer infrastructure code and becomes part ofthe  DealerServer daemon.</p><p class="P106"> </p><h1 class="P221"><a id="a__Coding_DealerServer_Metrics_Functions"><span/></a><a id="__RefHeading___Toc3469_3437249550"/>Coding DealerServer Metrics Functions</h1><p class="P108">This repo has code, written in C,  that implements many different evaluation metrics. The code is in the <span class="T56">UserEval </span>subdirectory of the dealerv2/src directory. The main files of interest are: <span class="T56">metrics_calcs.c</span> and <span class="T56">factors_subs.c </span>There is also a file, <span class="T56">metrics_util_subs.c </span>that provides some debug functions and some utility functions such as evaluating Quick Tricks, or Quick Losers, that are not specific to any one metric.</p><p class="P108">The factors_subs.c file contains code that implements parts of an overall metric, such as counting various flavors of HCP, various ways of correcting for short honors, or adding support points when a fit is found and so forth. There is nothing specific to the DealerServer infrastructure in any of them.</p><p class="P108">The starting point for the DealerServer program is the file, in the <span class="T56">include</span> directory, called <span class="T56">mmap_template.h </span>This file describes the layout of the shared memory area; where the DealerServer program can find its input and where it should place its output. The shared memory area is 4096 bytes, which on Linux represents one 'Virtual Page' of memory. It is the smallest unit of memory that Linux itself keeps track of. </p><p class="P108">The template file splits this 4096 bytes into three main areas:</p><ul><li><p class="P245" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;"></span>The header area, consisting of a description of the remaining areas, the information necessary to the infrastructure to establish communication, and the details of the current query.<span class="odfLiEnd"/> </p></li><li><p class="P245" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;"></span>The input data area. This area contains a copy of the deal itself, and of the<span class="T56"> handsta</span>t which has been filled out by the <span class="T56">analyze</span> function. The metrics calculation routines are thus spared the trouble of duplicating work that has already been done by Dealer in analyze, such as counting hcp, or determining suit lengths.<span class="odfLiEnd"/> </p></li><li><p class="P245" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;"></span>The results output area. This area has room to hold 64 integer results for each of the NS and EW sides. The metrics calculation routines put their results in this area. The usereval function picks up the results from the slot that has been specified in the usereval statement. <span class="odfLiEnd"/> </p></li></ul><p class="P109">The overall  execution flow of  DealerServer is:</p><ul><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Startup. Use the argc and argv arguments passed to main, to extract the file descriptor that was used to create and map the shared memory area.<span class="odfLiEnd"/> </p><ul><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Use this fd to map to the shared memory. Consult the template file to find the offset of the data structure that describes the semaphores.<span class="odfLiEnd"/> </p></li><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Open the query and response semaphores. <span class="odfLiEnd"/> </p></li><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Do any other startup tasks, such as opening a log file, and filling a structure with a set of pointers to all the various areas of the shared memory region using the offsets in the template file.<span class="odfLiEnd"/> </p></li></ul></li><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Main Loop. <span class="odfLiEnd"/> </p><ul><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Wait on the query semaphore. When a signal is retrieved, get the information about the query submitted, primarily its ID and which side it refers to from the shared memory region.<span class="odfLiEnd"/> </p></li><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Call a C function, <span class="T56">userfunc</span>, passing to that function, several of the pointers from the startup phase in case the user needs them. <span class="odfLiEnd"/> </p></li><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>userfunc then executes a switch statement which calls a generic 'reply' function. The reply function in turn calls one of the metrics_calcs functions.<span class="odfLiEnd"/> </p></li><li><p class="P246" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>When the metrics_calc function returns, post a reply to the Dealer client, and resume waiting on the semaphore for the next query.<span class="odfLiEnd"/> </p></li><li><p class="P247" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span><span class="T265">All of the code to this point is in the </span><span class="T83">User</span><span class="T84">Server.c</span><span class="T265"> </span><span class="T266"> file in the </span><span class="T83">UserEval/src/</span><span class="T111"> directory.</span><span class="odfLiEnd"/> </p></li></ul></li><li><p class="P248" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Metrics Calculation Functions.<span class="odfLiEnd"/> </p><ul><li><p class="P248" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>These functions have names such as bergen_calc, dkp_calc, karpin_calc and reside in the metrics_calcs.c file. They generally take a single argument, the side for which the value is to be computed. The general intent is that the first time they are called they will calculate all of the values that the user has asked for in the input file; this is a requirement, since otherwise the caching algorithm which only checks the side-tag combination will not work.<span class="odfLiEnd"/> </p></li><li><p class="P248" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>These metrics calcs use the code in factors_subs.c to determine the degree of fit, deductions for short honors, extra points for intermediates and so forth. When they have completed their role of calculating <span class="T157">all</span><span class="T166"> of the relevant values these are stored in the results area and the fucntion returns to the generic 'reply' function mentioned earlier.</span><span class="odfLiEnd"/> </p></li></ul></li></ul><p class="P109"> </p><ul><li><p class="P250" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0.635cm;">•</span>Using The Results<span class="odfLiEnd"/> </p><p class="P250" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm"><!-- --></span>The results area for the side NS<span class="T268">, </span> and also for the side EW<span class="T268">, </span> each have room for 64 integers. The easiest way to have the metrics_calcs functions work is to just have them put the results in the slots 0 .. 63, and then from the Dealer input file access them with clauses such as:<span class="odfLiEnd"/> </p><p class="P249" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm"><!-- --></span><span class="T86">usereval(10, NS, 16)</span><span class="T267"> or </span><span class="T86">usereval(4, EW, 63)</span><span class="T113">The user will need to keep track of which result goes to which slot, but that is fairly straightforward. You can also treat the results area as being split into four 16 slot areas. The first 16 slots are reserved for clauses such as the above, that is just specifying the tag, the side, and the slot number. The next </span><span class="T112">16 </span><span class="T113">(slots 16 to </span><span class="T112">31</span><span class="T113">) are the ones used for the results from clauses such as </span><span class="odfLiEnd"/> </p><p class="P249" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm"><!-- --></span><span class="T86">usereval(10, </span><span class="T85">NS</span><span class="T86">,</span><span class="T85"> spades,</span><span class="T86"> 0)</span><span class="T113"> or </span><span class="T86">usereval(4, </span><span class="T85">NS</span><span class="T86">, </span><span class="T85">clubs,3</span><span class="T86">).</span><span class="T113"> That is</span><span class="T112"> to say,</span><span class="T113"> there are </span><span class="T112">16</span><span class="T113"> slots reserved for the </span><span class="T112">side to report up to 4 values for each suit. </span><span class="T113"> But the user does not need to worry about that</span><span class="T112">;</span><span class="T113"> it is transparent. The slots </span><span class="T112">32 to 47</span><span class="T113"> are  used when the user enters </span><span class="T113">clauses with </span><span class="T112">a compass direction. There is room for each compass direction to return up to 8 different results, numbered 0 to 7 in clauses such as </span><span class="T85">usereval(0,north,0)</span><span class="T112"> or </span><span class="T85">usereval(9,south,7). </span><span class="T112">The last set of 16 allows each compass direction to return two results</span><span class="T114">, numbered 0 and 1, </span><span class="T112"> for each suit, with the syntax such as </span><span class="T85">usereval(5, south, spades, 1</span><span class="T112">) or </span><span class="T85">usereval(7,north,hearts,0).</span><span class="odfLiEnd"/> </p><p class="P251" style="margin-left:0cm;"><span class="Bullet_20_Symbols" style="display:block;float:left;min-width:0cm"><!-- --></span>The process is exactly the same if the user wants results for the EW side; just replace NS with EW, "north" with "east" and "south" with "west" in the above description.<span class="odfLiEnd"/> </p></li></ul><p class="P252"> </p><h2 class="Heading_20_2"><a id="a__Mixing_The_Results_from_Two_Different_Metrics_"><span/></a><a id="__RefHeading___Toc4839_2097399308"/>        Mixing The Results from Two Different <span class="T268">M</span>etrics.</h2><p class="P111"><span class="T114">        The usereval functionality is fairly efficient since it uses shared memory and a daemon that does not need to be started up from scratch each time. However it pays to be aware that when you ask for several different queries for the same side in the input file, </span><span class="T115">for example</span><span class="T114"> a query to evaluate the hands using the Bergen metric and then annother query to evaluate the hands using the Pavlicek metric for the same side</span><span class="T115">, then</span><span class="T114"> you will cause the server to be accessed once for each query and the cache will be overwritten each time you do so. If you then try to use the results from the query more than once, you may very well cause several calls to the DealerServer to be made each time.</span></p><p class="P110"><span class="T90">If you are concerned about the performance hit of doing this, you can take advantage of the fact that th</span><span class="T115">e</span><span class="T90">re is room for 64 results to be returned on each call, and a metric seldom needs more than five or six of them at most. Therefore you can code a 'mixed' query. In the case of our example of comparing Bergen ( query-id  0 ) and Pavlicek (query-id 10), we can make a mixed query, and give it the id 88 for example. Then when your code sees query-id 88 it can first run the Bergen calcs and store those results in slots 0 to 7 say, and then run the Pavlicek calcs and store those results in slot</span><span class="T115">s</span><span class="T90"> 8 to 15.</span></p><p class="P110"><span class="T90">As far as the caching mechanism is concerned you have run only one query, query 88, and those 16 results will be kept in the cache until the next deal.</span><span class="T115"> You then access these results with clauses such as </span><span class="T87">usereval(88, NS, 6)</span><span class="T115"> (for Bergen) or </span><span class="T87">usereval(88, NS, 13)</span><span class="T115">  (for Pavlicek).</span></p><p class="P253">If you further place your usereval clauses at the end of the condition statement as recommended for the other 'slower' functionallity of Dealer, such as DDS, GIB and OPC, your performance will be quite acceptable. </p></body></html>